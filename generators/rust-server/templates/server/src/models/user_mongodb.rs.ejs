use bson::{oid::ObjectId, DateTime as BsonDateTime};
use serde::{Deserialize, Serialize};

/// User entity for MongoDB
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct User {
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<ObjectId>,
    pub login: String,
    pub password_hash: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub first_name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_name: Option<String>,
    pub email: String,
    pub activated: bool,
<%_ if (enableEmail) { _%>
    /// Activation key for email verification
    #[serde(skip_serializing_if = "Option::is_none")]
    pub activation_key: Option<String>,
    /// Password reset key
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reset_key: Option<String>,
    /// When the reset key was generated
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reset_date: Option<BsonDateTime>,
<%_ } _%>
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lang_key: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub image_url: Option<String>,
    /// Authorities stored directly in user document (denormalized for MongoDB)
    #[serde(default)]
    pub authorities: Vec<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_by: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_date: Option<BsonDateTime>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified_by: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified_date: Option<BsonDateTime>,
}

/// New user for insertion
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NewUser {
    pub login: String,
    pub password_hash: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub first_name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_name: Option<String>,
    pub email: String,
    pub activated: bool,
<%_ if (enableEmail) { _%>
    #[serde(skip_serializing_if = "Option::is_none")]
    pub activation_key: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reset_key: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reset_date: Option<BsonDateTime>,
<%_ } _%>
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lang_key: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub image_url: Option<String>,
    #[serde(default)]
    pub authorities: Vec<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_by: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_date: Option<BsonDateTime>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified_by: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified_date: Option<BsonDateTime>,
}

/// User update changeset
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct UpdateUser {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub first_name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub activated: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lang_key: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub image_url: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorities: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified_by: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified_date: Option<BsonDateTime>,
}

impl User {
    /// Check if user has a specific authority/role
    pub fn has_authority(&self, authority: &str) -> bool {
        self.authorities.iter().any(|a| a == authority)
    }

    /// Get the user's ID as a hex string
    pub fn id_str(&self) -> String {
        self.id.map(|id| id.to_hex()).unwrap_or_default()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn create_test_user() -> User {
        User {
            id: Some(ObjectId::new()),
            login: "testuser".to_string(),
            password_hash: "$argon2id$hash".to_string(),
            first_name: Some("Test".to_string()),
            last_name: Some("User".to_string()),
            email: "test@example.com".to_string(),
            activated: true,
<%_ if (enableEmail) { _%>
            activation_key: None,
            reset_key: None,
            reset_date: None,
<%_ } _%>
            lang_key: Some("en".to_string()),
            image_url: None,
            authorities: vec!["ROLE_USER".to_string()],
            created_by: Some("system".to_string()),
            created_date: Some(BsonDateTime::now()),
            last_modified_by: Some("system".to_string()),
            last_modified_date: Some(BsonDateTime::now()),
        }
    }

    #[test]
    fn test_user_has_authority_true() {
        let user = create_test_user();
        assert!(user.has_authority("ROLE_USER"));
    }

    #[test]
    fn test_user_has_authority_false() {
        let user = create_test_user();
        assert!(!user.has_authority("ROLE_ADMIN"));
    }

    #[test]
    fn test_user_clone() {
        let user = create_test_user();
        let cloned = user.clone();
        assert_eq!(cloned.login, user.login);
        assert_eq!(cloned.email, user.email);
    }

    #[test]
    fn test_user_debug() {
        let user = create_test_user();
        let debug_str = format!("{:?}", user);
        assert!(debug_str.contains("testuser"));
        assert!(debug_str.contains("test@example.com"));
    }

    #[test]
    fn test_user_serialization_includes_password_hash() {
        // Note: password_hash is included in serialization for MongoDB storage
        // API responses should use UserDto which doesn't include password_hash
        let user = create_test_user();
        let json = serde_json::to_string(&user).unwrap();
        assert!(json.contains("password_hash"));
        assert!(json.contains("login"));
        assert!(json.contains("email"));
    }

    #[test]
    fn test_user_id_str() {
        let user = create_test_user();
        let id_str = user.id_str();
        assert!(!id_str.is_empty());
        assert_eq!(id_str.len(), 24); // ObjectId hex string length
    }

    #[test]
    fn test_new_user_creation() {
        let new_user = NewUser {
            login: "newuser".to_string(),
            password_hash: "$argon2id$newhash".to_string(),
            first_name: Some("New".to_string()),
            last_name: Some("User".to_string()),
            email: "new@example.com".to_string(),
            activated: false,
<%_ if (enableEmail) { _%>
            activation_key: Some("activation123".to_string()),
            reset_key: None,
            reset_date: None,
<%_ } _%>
            lang_key: Some("en".to_string()),
            image_url: None,
            authorities: vec!["ROLE_USER".to_string()],
            created_by: Some("admin".to_string()),
            created_date: None,
            last_modified_by: None,
            last_modified_date: None,
        };
        assert_eq!(new_user.login, "newuser");
        assert!(!new_user.activated);
    }

    #[test]
    fn test_update_user_default() {
        let update = UpdateUser::default();
        assert!(update.first_name.is_none());
        assert!(update.email.is_none());
        assert!(update.authorities.is_none());
    }
}
