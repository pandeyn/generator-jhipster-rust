use argon2::{
    password_hash::{PasswordHasher, SaltString},
    Argon2,
};
use rand::rngs::OsRng;
<%_ if (enableEmail) { _%>
use chrono::{NaiveDateTime, Utc};
<%_ } else { _%>
use chrono::Utc;
<%_ } _%>
use diesel::prelude::*;

use crate::db::connection::DbConnection;
use crate::db::schema::{user_authorities, users};
use crate::dto::{CreateUserDto, PageRequest, UpdateUserDto};
use crate::errors::AppError;
use crate::models::{NewUser, RoleType, UpdateUser, User, UserAuthority};

pub struct UserService;

impl UserService {
    /// Find all users with pagination
    pub fn find_all(
        conn: &mut DbConnection,
        page_request: &PageRequest,
    ) -> Result<(Vec<User>, i64), AppError> {
        let page = page_request.page.unwrap_or(0);
        let size = page_request.size.unwrap_or(20).min(100);
        let offset = page * size;

        let total: i64 = users::table
            .count()
            .get_result(conn)
            .map_err(|e| AppError::Internal(e.to_string()))?;

        // Get primary sort parameter (format: "field,direction" e.g., "login,asc" or "email,desc")
        let (sort_field, sort_dir) = page_request.primary_sort().unwrap_or(("id", "asc"));

        let is_desc = sort_dir.eq_ignore_ascii_case("desc");

        // Dynamic sorting based on field name
        let results = match sort_field {
            "login" => {
                if is_desc {
                    users::table
                        .order(users::login.desc())
                        .limit(size)
                        .offset(offset)
                        .load::<User>(conn)
                } else {
                    users::table
                        .order(users::login.asc())
                        .limit(size)
                        .offset(offset)
                        .load::<User>(conn)
                }
            }
            "email" => {
                if is_desc {
                    users::table
                        .order(users::email.desc())
                        .limit(size)
                        .offset(offset)
                        .load::<User>(conn)
                } else {
                    users::table
                        .order(users::email.asc())
                        .limit(size)
                        .offset(offset)
                        .load::<User>(conn)
                }
            }
            "firstName" | "first_name" => {
                if is_desc {
                    users::table
                        .order(users::first_name.desc())
                        .limit(size)
                        .offset(offset)
                        .load::<User>(conn)
                } else {
                    users::table
                        .order(users::first_name.asc())
                        .limit(size)
                        .offset(offset)
                        .load::<User>(conn)
                }
            }
            "lastName" | "last_name" => {
                if is_desc {
                    users::table
                        .order(users::last_name.desc())
                        .limit(size)
                        .offset(offset)
                        .load::<User>(conn)
                } else {
                    users::table
                        .order(users::last_name.asc())
                        .limit(size)
                        .offset(offset)
                        .load::<User>(conn)
                }
            }
            "langKey" | "lang_key" => {
                if is_desc {
                    users::table
                        .order(users::lang_key.desc())
                        .limit(size)
                        .offset(offset)
                        .load::<User>(conn)
                } else {
                    users::table
                        .order(users::lang_key.asc())
                        .limit(size)
                        .offset(offset)
                        .load::<User>(conn)
                }
            }
            "activated" => {
                if is_desc {
                    users::table
                        .order(users::activated.desc())
                        .limit(size)
                        .offset(offset)
                        .load::<User>(conn)
                } else {
                    users::table
                        .order(users::activated.asc())
                        .limit(size)
                        .offset(offset)
                        .load::<User>(conn)
                }
            }
            "createdDate" | "created_date" => {
                if is_desc {
                    users::table
                        .order(users::created_date.desc())
                        .limit(size)
                        .offset(offset)
                        .load::<User>(conn)
                } else {
                    users::table
                        .order(users::created_date.asc())
                        .limit(size)
                        .offset(offset)
                        .load::<User>(conn)
                }
            }
            "lastModifiedDate" | "last_modified_date" => {
                if is_desc {
                    users::table
                        .order(users::last_modified_date.desc())
                        .limit(size)
                        .offset(offset)
                        .load::<User>(conn)
                } else {
                    users::table
                        .order(users::last_modified_date.asc())
                        .limit(size)
                        .offset(offset)
                        .load::<User>(conn)
                }
            }
            _ => {
                // Default: sort by id
                if is_desc {
                    users::table
                        .order(users::id.desc())
                        .limit(size)
                        .offset(offset)
                        .load::<User>(conn)
                } else {
                    users::table
                        .order(users::id.asc())
                        .limit(size)
                        .offset(offset)
                        .load::<User>(conn)
                }
            }
        }
        .map_err(|e| AppError::Internal(e.to_string()))?;

        Ok((results, total))
    }

    /// Find user by ID
    pub fn find_by_id(conn: &mut DbConnection, id: i32) -> Result<User, AppError> {
        users::table
            .find(id)
            .first::<User>(conn)
            .map_err(|e| match e {
                diesel::result::Error::NotFound => AppError::NotFound(format!("User {} not found", id)),
                _ => AppError::Internal(e.to_string()),
            })
    }

    /// Find user by login
    pub fn find_by_login(conn: &mut DbConnection, login: &str) -> Result<User, AppError> {
        users::table
            .filter(users::login.eq(login))
            .first::<User>(conn)
            .map_err(|e| match e {
                diesel::result::Error::NotFound => {
                    AppError::NotFound(format!("User {} not found", login))
                }
                _ => AppError::Internal(e.to_string()),
            })
    }

    /// Find user by email
    pub fn find_by_email(conn: &mut DbConnection, email: &str) -> Result<User, AppError> {
        users::table
            .filter(users::email.eq(email))
            .first::<User>(conn)
            .map_err(|e| match e {
                diesel::result::Error::NotFound => {
                    AppError::NotFound(format!("User with email {} not found", email))
                }
                _ => AppError::Internal(e.to_string()),
            })
    }

    /// Get authorities for a user
    pub fn get_authorities(conn: &mut DbConnection, user_id: i32) -> Result<Vec<String>, AppError> {
        user_authorities::table
            .filter(user_authorities::user_id.eq(user_id))
            .select(user_authorities::authority_name)
            .load::<String>(conn)
            .map_err(|e| AppError::Internal(e.to_string()))
    }

    /// Create a new user
    pub fn create(
        conn: &mut DbConnection,
        dto: CreateUserDto,
        created_by: &str,
    ) -> Result<User, AppError> {
        // Check if login already exists
        if users::table
            .filter(users::login.eq(&dto.login))
            .first::<User>(conn)
            .is_ok()
        {
            return Err(AppError::BadRequest("Login already exists".to_string()));
        }

        // Check if email already exists
        if users::table
            .filter(users::email.eq(&dto.email))
            .first::<User>(conn)
            .is_ok()
        {
            return Err(AppError::BadRequest("Email already exists".to_string()));
        }

        // Hash the password
        let password_hash = Self::hash_password(&dto.password)?;
        let now = Utc::now().naive_utc();

        let new_user = NewUser {
            login: dto.login,
            password_hash,
            first_name: dto.first_name,
            last_name: dto.last_name,
            email: dto.email,
            activated: dto.activated.unwrap_or(false),
            lang_key: dto.lang_key,
            image_url: dto.image_url,
            created_by: Some(created_by.to_string()),
            created_date: Some(now),
            last_modified_by: Some(created_by.to_string()),
            last_modified_date: Some(now),
        };

        diesel::insert_into(users::table)
            .values(&new_user)
            .execute(conn)
            .map_err(|e| AppError::Internal(e.to_string()))?;

        // SQLite doesn't support RETURNING, so we fetch the inserted user by login
        let user = users::table
            .filter(users::login.eq(&new_user.login))
            .first::<User>(conn)
            .map_err(|e| AppError::Internal(e.to_string()))?;

        // Add default role
        let authorities = dto.authorities.unwrap_or_else(|| vec![RoleType::USER.to_string()]);
        for authority in authorities {
            diesel::insert_into(user_authorities::table)
                .values(UserAuthority {
                    user_id: user.id,
                    authority_name: authority,
                })
                .execute(conn)
                .map_err(|e| AppError::Internal(e.to_string()))?;
        }

        Ok(user)
    }

    /// Update an existing user
    pub fn update(
        conn: &mut DbConnection,
        id: i32,
        dto: UpdateUserDto,
        modified_by: &str,
    ) -> Result<User, AppError> {
        let now = Utc::now().naive_utc();

        let update = UpdateUser {
            first_name: dto.first_name,
            last_name: dto.last_name,
            email: dto.email,
            activated: dto.activated,
            lang_key: dto.lang_key,
            image_url: dto.image_url,
            last_modified_by: Some(modified_by.to_string()),
            last_modified_date: Some(now),
        };

        diesel::update(users::table.find(id))
            .set(&update)
            .execute(conn)
            .map_err(|e| AppError::Internal(e.to_string()))?;

        // Update authorities if provided
        if let Some(authorities) = dto.authorities {
            // Remove existing authorities
            diesel::delete(user_authorities::table.filter(user_authorities::user_id.eq(id)))
                .execute(conn)
                .map_err(|e| AppError::Internal(e.to_string()))?;

            // Add new authorities
            for authority in authorities {
                diesel::insert_into(user_authorities::table)
                    .values(UserAuthority {
                        user_id: id,
                        authority_name: authority,
                    })
                    .execute(conn)
                    .map_err(|e| AppError::Internal(e.to_string()))?;
            }
        }

        Self::find_by_id(conn, id)
    }

    /// Delete a user
    pub fn delete(conn: &mut DbConnection, id: i32) -> Result<(), AppError> {
        // Delete user authorities first
        diesel::delete(user_authorities::table.filter(user_authorities::user_id.eq(id)))
            .execute(conn)
            .map_err(|e| AppError::Internal(e.to_string()))?;

        // Delete user
        diesel::delete(users::table.find(id))
            .execute(conn)
            .map_err(|e| AppError::Internal(e.to_string()))?;

        Ok(())
    }

    /// Hash a password using Argon2
    pub fn hash_password(password: &str) -> Result<String, AppError> {
        let salt = SaltString::generate(&mut OsRng);
        let argon2 = Argon2::default();

        argon2
            .hash_password(password.as_bytes(), &salt)
            .map(|hash| hash.to_string())
            .map_err(|e| AppError::Internal(format!("Failed to hash password: {}", e)))
    }

    /// Update user's password
    pub fn update_password(
        conn: &mut DbConnection,
        login: &str,
        password_hash: &str,
    ) -> Result<(), AppError> {
        diesel::update(users::table.filter(users::login.eq(login)))
            .set(users::password_hash.eq(password_hash))
            .execute(conn)
            .map_err(|e| AppError::Internal(e.to_string()))?;

        Ok(())
    }

    /// Update current user's account settings (used by POST /api/account)
    pub fn update_account(
        conn: &mut DbConnection,
        login: &str,
        first_name: Option<String>,
        last_name: Option<String>,
        email: String,
        lang_key: Option<String>,
        image_url: Option<String>,
    ) -> Result<(), AppError> {
        let now = Utc::now().naive_utc();

        diesel::update(users::table.filter(users::login.eq(login)))
            .set((
                users::first_name.eq(first_name),
                users::last_name.eq(last_name),
                users::email.eq(email),
                users::lang_key.eq(lang_key),
                users::image_url.eq(image_url),
                users::last_modified_by.eq(login),
                users::last_modified_date.eq(now),
            ))
            .execute(conn)
            .map_err(|e| AppError::Internal(e.to_string()))?;

        Ok(())
    }

    /// Create a user with authorities (used for testing and seeding)
    pub fn create_with_authorities(
        conn: &mut DbConnection,
        new_user: NewUser,
        authorities: Vec<String>,
    ) -> Result<User, AppError> {
        diesel::insert_into(users::table)
            .values(&new_user)
            .execute(conn)
            .map_err(|e| AppError::Internal(e.to_string()))?;

        // SQLite doesn't support RETURNING, so we fetch the inserted user by login
        let user = users::table
            .filter(users::login.eq(&new_user.login))
            .first::<User>(conn)
            .map_err(|e| AppError::Internal(e.to_string()))?;

        // Add authorities
        for authority in authorities {
            diesel::insert_into(user_authorities::table)
                .values(UserAuthority {
                    user_id: user.id,
                    authority_name: authority,
                })
                .execute(conn)
                .map_err(|e| AppError::Internal(e.to_string()))?;
        }

        Ok(user)
    }

<%_ if (!enableEmail) { _%>
    /// Create a new registered user (already activated, used when email is disabled)
    pub fn create_registered_user(
        conn: &mut DbConnection,
        login: String,
        email: String,
        password: &str,
        lang_key: Option<String>,
    ) -> Result<User, AppError> {
        // Check if login already exists
        if users::table
            .filter(users::login.eq(&login))
            .first::<User>(conn)
            .is_ok()
        {
            return Err(AppError::BadRequest("Login already exists".to_string()));
        }

        // Check if email already exists
        if users::table
            .filter(users::email.eq(&email))
            .first::<User>(conn)
            .is_ok()
        {
            return Err(AppError::BadRequest("Email already exists".to_string()));
        }

        // Hash the password
        let password_hash = Self::hash_password(password)?;
        let now = Utc::now().naive_utc();

        let new_user = NewUser {
            login: login.to_lowercase(),
            password_hash,
            first_name: None,
            last_name: None,
            email: email.to_lowercase(),
            activated: true,  // Already activated since email is disabled
            lang_key,
            image_url: None,
            created_by: Some("anonymousUser".to_string()),
            created_date: Some(now),
            last_modified_by: Some("anonymousUser".to_string()),
            last_modified_date: Some(now),
        };

        diesel::insert_into(users::table)
            .values(&new_user)
            .execute(conn)
            .map_err(|e| AppError::Internal(e.to_string()))?;

        // Fetch the inserted user
        let user = users::table
            .filter(users::login.eq(&new_user.login))
            .first::<User>(conn)
            .map_err(|e| AppError::Internal(e.to_string()))?;

        // Add default ROLE_USER
        diesel::insert_into(user_authorities::table)
            .values(UserAuthority {
                user_id: user.id,
                authority_name: RoleType::USER.to_string(),
            })
            .execute(conn)
            .map_err(|e| AppError::Internal(e.to_string()))?;

        Ok(user)
    }
<%_ } _%>

<%_ if (enableEmail) { _%>
    /// Find user by email (case-insensitive)
    pub fn find_by_email_ignore_case(conn: &mut DbConnection, email: &str) -> Result<Option<User>, AppError> {
        use diesel::dsl::sql;
        use diesel::sql_types::Text;

        users::table
            .filter(sql::<Text>("LOWER(email)").eq(email.to_lowercase()))
            .first::<User>(conn)
            .optional()
            .map_err(|e| AppError::Internal(e.to_string()))
    }

    /// Find user by login (case-insensitive) that is not activated
    pub fn find_non_activated_by_login(conn: &mut DbConnection, login: &str) -> Result<Option<User>, AppError> {
        use diesel::dsl::sql;
        use diesel::sql_types::Text;

        users::table
            .filter(sql::<Text>("LOWER(login)").eq(login.to_lowercase()))
            .filter(users::activated.eq(false))
            .first::<User>(conn)
            .optional()
            .map_err(|e| AppError::Internal(e.to_string()))
    }

    /// Delete non-activated user by login (used to clean up before re-registration)
    pub fn delete_non_activated_by_login(conn: &mut DbConnection, login: &str) -> Result<(), AppError> {
        if let Some(user) = Self::find_non_activated_by_login(conn, login)? {
            Self::delete(conn, user.id)?;
        }
        Ok(())
    }

    /// Create a new user with activation key for email verification
    pub fn create_with_activation(
        conn: &mut DbConnection,
        login: String,
        email: String,
        password: &str,
        lang_key: Option<String>,
        activation_key: String,
    ) -> Result<User, AppError> {
        // Check if login already exists (activated user)
        if let Ok(existing) = Self::find_by_login(conn, &login) {
            if existing.activated {
                return Err(AppError::BadRequest("Login already exists".to_string()));
            }
        }

        // Check if email already exists (activated user)
        if let Some(existing) = Self::find_by_email_ignore_case(conn, &email)? {
            if existing.activated {
                return Err(AppError::BadRequest("Email already exists".to_string()));
            }
        }

        // Delete any existing non-activated user with the same login
        Self::delete_non_activated_by_login(conn, &login)?;

        // Hash the password
        let password_hash = Self::hash_password(password)?;
        let now = Utc::now().naive_utc();

        let new_user = NewUser {
            login: login.to_lowercase(),
            password_hash,
            first_name: None,
            last_name: None,
            email: email.to_lowercase(),
            activated: false,
            activation_key: Some(activation_key),
            reset_key: None,
            reset_date: None,
            lang_key,
            image_url: None,
            created_by: Some("system".to_string()),
            created_date: Some(now),
            last_modified_by: Some("system".to_string()),
            last_modified_date: Some(now),
        };

        diesel::insert_into(users::table)
            .values(&new_user)
            .execute(conn)
            .map_err(|e| AppError::Internal(e.to_string()))?;

        // Fetch the inserted user
        let user = users::table
            .filter(users::login.eq(&new_user.login))
            .first::<User>(conn)
            .map_err(|e| AppError::Internal(e.to_string()))?;

        // Add default ROLE_USER
        diesel::insert_into(user_authorities::table)
            .values(UserAuthority {
                user_id: user.id,
                authority_name: RoleType::USER.to_string(),
            })
            .execute(conn)
            .map_err(|e| AppError::Internal(e.to_string()))?;

        Ok(user)
    }

    /// Activate a user by activation key
    pub fn activate_by_key(conn: &mut DbConnection, key: &str) -> Result<Option<User>, AppError> {
        // Find user with this activation key
        let user = users::table
            .filter(users::activation_key.eq(key))
            .first::<User>(conn)
            .optional()
            .map_err(|e| AppError::Internal(e.to_string()))?;

        if let Some(user) = user {
            let now = Utc::now().naive_utc();

            // Activate the user and clear activation key
            diesel::update(users::table.find(user.id))
                .set((
                    users::activated.eq(true),
                    users::activation_key.eq::<Option<String>>(None),
                    users::last_modified_by.eq("system"),
                    users::last_modified_date.eq(now),
                ))
                .execute(conn)
                .map_err(|e| AppError::Internal(e.to_string()))?;

            Self::find_by_id(conn, user.id).map(Some)
        } else {
            Ok(None)
        }
    }

    /// Set reset key for password reset
    pub fn set_reset_key(conn: &mut DbConnection, user_id: i32, reset_key: String) -> Result<User, AppError> {
        let now = Utc::now().naive_utc();

        diesel::update(users::table.find(user_id))
            .set((
                users::reset_key.eq(Some(reset_key)),
                users::reset_date.eq(Some(now)),
                users::last_modified_by.eq("system"),
                users::last_modified_date.eq(now),
            ))
            .execute(conn)
            .map_err(|e| AppError::Internal(e.to_string()))?;

        Self::find_by_id(conn, user_id)
    }

    /// Complete password reset using reset key
    /// Returns None if key not found or expired (24 hours)
    pub fn complete_password_reset(
        conn: &mut DbConnection,
        new_password: &str,
        key: &str,
    ) -> Result<Option<User>, AppError> {
        use chrono::Duration;

        // Find user with this reset key
        let user = users::table
            .filter(users::reset_key.eq(key))
            .first::<User>(conn)
            .optional()
            .map_err(|e| AppError::Internal(e.to_string()))?;

        if let Some(user) = user {
            // Check if reset key is expired (24 hours)
            if let Some(reset_date) = user.reset_date {
                let now = Utc::now().naive_utc();
                let expiry = reset_date + Duration::hours(24);

                if now > expiry {
                    // Reset key expired
                    return Ok(None);
                }
            } else {
                // No reset date set, invalid state
                return Ok(None);
            }

            // Hash new password
            let password_hash = Self::hash_password(new_password)?;
            let now = Utc::now().naive_utc();

            // Update password and clear reset key
            diesel::update(users::table.find(user.id))
                .set((
                    users::password_hash.eq(password_hash),
                    users::reset_key.eq::<Option<String>>(None),
                    users::reset_date.eq::<Option<NaiveDateTime>>(None),
                    users::last_modified_by.eq("system"),
                    users::last_modified_date.eq(now),
                ))
                .execute(conn)
                .map_err(|e| AppError::Internal(e.to_string()))?;

            Self::find_by_id(conn, user.id).map(Some)
        } else {
            Ok(None)
        }
    }
<%_ } _%>
}

#[cfg(test)]
mod tests {
    use super::*;

    mod unit_tests {
        use super::*;

        #[test]
        fn test_hash_password_success() {
            let password = "my_secure_password";
            let result = UserService::hash_password(password);
            assert!(result.is_ok());
            let hash = result.unwrap();
            assert!(!hash.is_empty());
            // Argon2 hashes start with $argon2
            assert!(hash.starts_with("$argon2"));
        }

        #[test]
        fn test_hash_password_different_outputs() {
            let password = "same_password";
            let hash1 = UserService::hash_password(password).unwrap();
            let hash2 = UserService::hash_password(password).unwrap();
            // Due to random salt, same password should produce different hashes
            assert_ne!(hash1, hash2);
        }

        #[test]
        fn test_hash_password_empty_string() {
            let result = UserService::hash_password("");
            // Empty password should still be hashable
            assert!(result.is_ok());
        }

        #[test]
        fn test_hash_password_long_password() {
            let password = "a".repeat(1000);
            let result = UserService::hash_password(&password);
            assert!(result.is_ok());
        }

        #[test]
        fn test_hash_password_special_characters() {
            let password = "p@$$w0rd!#$%^&*()";
            let result = UserService::hash_password(password);
            assert!(result.is_ok());
        }

        #[test]
        fn test_hash_password_unicode() {
            let password = "–ø–∞—Ä–æ–ª—åÂØÜÁ†Åüîê";
            let result = UserService::hash_password(password);
            assert!(result.is_ok());
        }
    }

    mod integration_tests {
        use super::*;
        use crate::test_utils::create_test_pool;
        use crate::dto::{CreateUserDto, PageRequest, UpdateUserDto};

        #[test]
        fn test_create_user() {
            let pool = create_test_pool();
            let mut conn = pool.get().unwrap();

            let dto = CreateUserDto {
                login: "testuser".to_string(),
                password: "password123".to_string(),
                first_name: Some("Test".to_string()),
                last_name: Some("User".to_string()),
                email: "testuser@example.com".to_string(),
                activated: Some(true),
                lang_key: Some("en".to_string()),
                image_url: None,
                authorities: Some(vec!["ROLE_USER".to_string()]),
            };

            let result = UserService::create(&mut conn, dto, "system");
            assert!(result.is_ok());

            let user = result.unwrap();
            assert_eq!(user.login, "testuser");
            assert_eq!(user.email, "testuser@example.com");
            assert!(user.activated);
        }

        #[test]
        fn test_create_user_duplicate_login() {
            let pool = create_test_pool();
            let mut conn = pool.get().unwrap();

            let dto = CreateUserDto {
                login: "duplicate".to_string(),
                password: "password123".to_string(),
                first_name: None,
                last_name: None,
                email: "first@example.com".to_string(),
                activated: Some(true),
                lang_key: None,
                image_url: None,
                authorities: None,
            };

            // First creation should succeed
            assert!(UserService::create(&mut conn, dto.clone(), "system").is_ok());

            // Second creation with same login should fail
            let dto2 = CreateUserDto {
                login: "duplicate".to_string(),
                password: "password123".to_string(),
                first_name: None,
                last_name: None,
                email: "second@example.com".to_string(),
                activated: Some(true),
                lang_key: None,
                image_url: None,
                authorities: None,
            };

            let result = UserService::create(&mut conn, dto2, "system");
            assert!(result.is_err());
        }

        #[test]
        fn test_create_user_duplicate_email() {
            let pool = create_test_pool();
            let mut conn = pool.get().unwrap();

            let dto = CreateUserDto {
                login: "user1".to_string(),
                password: "password123".to_string(),
                first_name: None,
                last_name: None,
                email: "same@example.com".to_string(),
                activated: Some(true),
                lang_key: None,
                image_url: None,
                authorities: None,
            };

            // First creation should succeed
            assert!(UserService::create(&mut conn, dto, "system").is_ok());

            // Second creation with same email should fail
            let dto2 = CreateUserDto {
                login: "user2".to_string(),
                password: "password123".to_string(),
                first_name: None,
                last_name: None,
                email: "same@example.com".to_string(),
                activated: Some(true),
                lang_key: None,
                image_url: None,
                authorities: None,
            };

            let result = UserService::create(&mut conn, dto2, "system");
            assert!(result.is_err());
        }

        #[test]
        fn test_find_by_id() {
            let pool = create_test_pool();
            let mut conn = pool.get().unwrap();

            // Create a user first
            let dto = CreateUserDto {
                login: "findbyid".to_string(),
                password: "password123".to_string(),
                first_name: Some("Find".to_string()),
                last_name: Some("ById".to_string()),
                email: "findbyid@example.com".to_string(),
                activated: Some(true),
                lang_key: None,
                image_url: None,
                authorities: None,
            };

            let created = UserService::create(&mut conn, dto, "system").unwrap();
            let found = UserService::find_by_id(&mut conn, created.id).unwrap();

            assert_eq!(found.login, "findbyid");
            assert_eq!(found.email, "findbyid@example.com");
        }

        #[test]
        fn test_find_by_id_not_found() {
            let pool = create_test_pool();
            let mut conn = pool.get().unwrap();

            let result = UserService::find_by_id(&mut conn, 99999);
            assert!(result.is_err());
        }

        #[test]
        fn test_find_by_login() {
            let pool = create_test_pool();
            let mut conn = pool.get().unwrap();

            let dto = CreateUserDto {
                login: "findbylogin".to_string(),
                password: "password123".to_string(),
                first_name: None,
                last_name: None,
                email: "findbylogin@example.com".to_string(),
                activated: Some(true),
                lang_key: None,
                image_url: None,
                authorities: None,
            };

            UserService::create(&mut conn, dto, "system").unwrap();
            let found = UserService::find_by_login(&mut conn, "findbylogin").unwrap();

            assert_eq!(found.login, "findbylogin");
        }

        #[test]
        fn test_find_by_email() {
            let pool = create_test_pool();
            let mut conn = pool.get().unwrap();

            let dto = CreateUserDto {
                login: "findbyemail".to_string(),
                password: "password123".to_string(),
                first_name: None,
                last_name: None,
                email: "findbyemail@example.com".to_string(),
                activated: Some(true),
                lang_key: None,
                image_url: None,
                authorities: None,
            };

            UserService::create(&mut conn, dto, "system").unwrap();
            let found = UserService::find_by_email(&mut conn, "findbyemail@example.com").unwrap();

            assert_eq!(found.login, "findbyemail");
        }

        #[test]
        fn test_find_all_with_pagination() {
            let pool = create_test_pool();
            let mut conn = pool.get().unwrap();

            // Count existing users from migrations (admin and user are seeded)
            let initial_page_request = PageRequest {
                page: Some(0),
                size: Some(100),
                sort: Vec::new(),
            };
            let (_, initial_count) = UserService::find_all(&mut conn, &initial_page_request).unwrap();

            // Create multiple users
            for i in 0..5 {
                let dto = CreateUserDto {
                    login: format!("paguser{}", i),
                    password: "password123".to_string(),
                    first_name: Some(format!("User{}", i)),
                    last_name: None,
                    email: format!("paguser{}@example.com", i),
                    activated: Some(true),
                    lang_key: None,
                    image_url: None,
                    authorities: None,
                };
                UserService::create(&mut conn, dto, "system").unwrap();
            }

            // Test pagination
            let page_request = PageRequest {
                page: Some(0),
                size: Some(2),
                sort: Vec::new(),
            };

            let (users, total) = UserService::find_all(&mut conn, &page_request).unwrap();
            assert_eq!(users.len(), 2);
            assert_eq!(total, initial_count + 5); // 5 new users plus any seeded users
        }

        #[test]
        fn test_find_all_with_sorting() {
            let pool = create_test_pool();
            let mut conn = pool.get().unwrap();

            // Create users with different logins that sort after 'admin' and 'user' (the seeded users)
            for login in ["zcharlie", "zalice", "zbob"] {
                let dto = CreateUserDto {
                    login: login.to_string(),
                    password: "password123".to_string(),
                    first_name: None,
                    last_name: None,
                    email: format!("{}@example.com", login),
                    activated: Some(true),
                    lang_key: None,
                    image_url: None,
                    authorities: None,
                };
                UserService::create(&mut conn, dto, "system").unwrap();
            }

            // Test ascending sort - admin comes first, then user, then z* users
            let page_request = PageRequest {
                page: Some(0),
                size: Some(10),
                sort: vec!["login,asc".to_string()],
            };

            let (users, _) = UserService::find_all(&mut conn, &page_request).unwrap();
            // First two are admin and user from migrations
            // Then z* users in alphabetical order
            let z_users: Vec<_> = users.iter().filter(|u| u.login.starts_with('z')).collect();
            assert!(z_users.len() >= 3);
            assert_eq!(z_users[0].login, "zalice");
            assert_eq!(z_users[1].login, "zbob");
            assert_eq!(z_users[2].login, "zcharlie");
        }

        #[test]
        fn test_update_user() {
            let pool = create_test_pool();
            let mut conn = pool.get().unwrap();

            // Create a user
            let dto = CreateUserDto {
                login: "toupdate".to_string(),
                password: "password123".to_string(),
                first_name: Some("Original".to_string()),
                last_name: Some("Name".to_string()),
                email: "toupdate@example.com".to_string(),
                activated: Some(false),
                lang_key: None,
                image_url: None,
                authorities: None,
            };

            let created = UserService::create(&mut conn, dto, "system").unwrap();

            // Update the user
            let update_dto = UpdateUserDto {
                login: None,
                first_name: Some("Updated".to_string()),
                last_name: Some("User".to_string()),
                email: Some("updated@example.com".to_string()),
                activated: Some(true),
                lang_key: Some("fr".to_string()),
                image_url: None,
                authorities: None,
            };

            let updated = UserService::update(&mut conn, created.id, update_dto, "admin").unwrap();

            assert_eq!(updated.first_name, Some("Updated".to_string()));
            assert_eq!(updated.last_name, Some("User".to_string()));
            assert_eq!(updated.email, "updated@example.com");
            assert!(updated.activated);
            assert_eq!(updated.lang_key, Some("fr".to_string()));
        }

        #[test]
        fn test_update_user_authorities() {
            let pool = create_test_pool();
            let mut conn = pool.get().unwrap();

            // Create a user with USER role
            let dto = CreateUserDto {
                login: "authupdate".to_string(),
                password: "password123".to_string(),
                first_name: None,
                last_name: None,
                email: "authupdate@example.com".to_string(),
                activated: Some(true),
                lang_key: None,
                image_url: None,
                authorities: Some(vec!["ROLE_USER".to_string()]),
            };

            let created = UserService::create(&mut conn, dto, "system").unwrap();

            // Update to add ADMIN role
            let update_dto = UpdateUserDto {
                login: None,
                first_name: None,
                last_name: None,
                email: None,
                activated: None,
                lang_key: None,
                image_url: None,
                authorities: Some(vec!["ROLE_USER".to_string(), "ROLE_ADMIN".to_string()]),
            };

            UserService::update(&mut conn, created.id, update_dto, "admin").unwrap();

            let authorities = UserService::get_authorities(&mut conn, created.id).unwrap();
            assert!(authorities.contains(&"ROLE_USER".to_string()));
            assert!(authorities.contains(&"ROLE_ADMIN".to_string()));
        }

        #[test]
        fn test_delete_user() {
            let pool = create_test_pool();
            let mut conn = pool.get().unwrap();

            // Create a user
            let dto = CreateUserDto {
                login: "todelete".to_string(),
                password: "password123".to_string(),
                first_name: None,
                last_name: None,
                email: "todelete@example.com".to_string(),
                activated: Some(true),
                lang_key: None,
                image_url: None,
                authorities: None,
            };

            let created = UserService::create(&mut conn, dto, "system").unwrap();

            // Delete the user
            let result = UserService::delete(&mut conn, created.id);
            assert!(result.is_ok());

            // Verify user is deleted
            let find_result = UserService::find_by_id(&mut conn, created.id);
            assert!(find_result.is_err());
        }

        #[test]
        fn test_get_authorities() {
            let pool = create_test_pool();
            let mut conn = pool.get().unwrap();

            let dto = CreateUserDto {
                login: "withauth".to_string(),
                password: "password123".to_string(),
                first_name: None,
                last_name: None,
                email: "withauth@example.com".to_string(),
                activated: Some(true),
                lang_key: None,
                image_url: None,
                authorities: Some(vec!["ROLE_USER".to_string(), "ROLE_ADMIN".to_string()]),
            };

            let created = UserService::create(&mut conn, dto, "system").unwrap();
            let authorities = UserService::get_authorities(&mut conn, created.id).unwrap();

            assert_eq!(authorities.len(), 2);
            assert!(authorities.contains(&"ROLE_USER".to_string()));
            assert!(authorities.contains(&"ROLE_ADMIN".to_string()));
        }

        #[test]
        fn test_update_password() {
            let pool = create_test_pool();
            let mut conn = pool.get().unwrap();

            let dto = CreateUserDto {
                login: "pwdupdate".to_string(),
                password: "oldpassword".to_string(),
                first_name: None,
                last_name: None,
                email: "pwdupdate@example.com".to_string(),
                activated: Some(true),
                lang_key: None,
                image_url: None,
                authorities: None,
            };

            UserService::create(&mut conn, dto, "system").unwrap();

            // Update password
            let new_hash = UserService::hash_password("newpassword").unwrap();
            let result = UserService::update_password(&mut conn, "pwdupdate", &new_hash);
            assert!(result.is_ok());

            // Verify password was updated
            let user = UserService::find_by_login(&mut conn, "pwdupdate").unwrap();
            assert_eq!(user.password_hash, new_hash);
        }

        #[test]
        fn test_create_with_authorities() {
            let pool = create_test_pool();
            let mut conn = pool.get().unwrap();

            let password_hash = UserService::hash_password("password123").unwrap();
            let new_user = NewUser {
                login: "directcreate".to_string(),
                password_hash,
                first_name: Some("Direct".to_string()),
                last_name: Some("Create".to_string()),
                email: "directcreate@example.com".to_string(),
                activated: true,
                lang_key: Some("en".to_string()),
                image_url: None,
                created_by: Some("test".to_string()),
                created_date: Some(chrono::Utc::now().naive_utc()),
                last_modified_by: Some("test".to_string()),
                last_modified_date: Some(chrono::Utc::now().naive_utc()),
            };

            let result = UserService::create_with_authorities(
                &mut conn,
                new_user,
                vec!["ROLE_USER".to_string(), "ROLE_ADMIN".to_string()],
            );

            assert!(result.is_ok());
            let user = result.unwrap();
            assert_eq!(user.login, "directcreate");

            let authorities = UserService::get_authorities(&mut conn, user.id).unwrap();
            assert_eq!(authorities.len(), 2);
        }
    }
}
