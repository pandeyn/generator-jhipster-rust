use chrono::Utc;
use diesel::prelude::*;

use crate::db::connection::DbConnection;
use crate::db::schema::<%= entityTableName %>;
<%_ const manyToManyOwnerRels = relationships.filter(r => r.relationshipType === 'many-to-many' && r.ownerSide); _%>
<%_ const manyToOneRels = relationships.filter(r => r.relationshipType === 'many-to-one' || (r.relationshipType === 'one-to-one' && r.ownerSide)); _%>
<%_ for (const rel of manyToOneRels) { _%>
use crate::db::schema::<%= rel.otherEntityTableName %>;
<%_ } _%>
<%_ for (const rel of manyToManyOwnerRels) { _%>
use crate::db::schema::<%= rel.joinTable.name %>;
use crate::db::schema::<%= rel.otherEntityTableName %>;
<%_ } _%>
use crate::dto::{Create<%= entityClass %>Dto, PageRequest, Update<%= entityClass %>Dto};
use crate::errors::AppError;
<%_ if (manyToManyOwnerRels.length > 0 || manyToOneRels.length > 0) { _%>
use crate::models::{New<%= persistClass %>, Update<%= persistClass %>, <%= persistClass %><% for (const rel of manyToOneRels) { %>, <%= rel.otherEntity.persistClass %><% } %><% for (const rel of manyToManyOwnerRels) { %>, <%= persistClass %><%= rel.otherEntity.persistClass %>, <%= rel.otherEntity.persistClass %><% } %>};
<%_ } else { _%>
use crate::models::{New<%= persistClass %>, Update<%= persistClass %>, <%= persistClass %>};
<%_ } _%>

pub struct <%= entityClass %>Service;

impl <%= entityClass %>Service {
    /// Find all <%= entityInstancePlural %> with pagination
    pub fn find_all(
        conn: &mut DbConnection,
        page_request: &PageRequest,
    ) -> Result<(Vec<<%= persistClass %>>, i64), AppError> {
        let page = page_request.page.unwrap_or(0);
        let size = page_request.size.unwrap_or(20).min(100);
        let offset = page * size;

        let total: i64 = <%= entityTableName %>::table
            .count()
            .get_result(conn)
            .map_err(|e| AppError::Internal(e.to_string()))?;

        // Get primary sort parameter (format: "field,direction" e.g., "name,asc" or "cost,desc")
        let (sort_field, sort_dir) = page_request.primary_sort().unwrap_or(("id", "asc"));

        let is_desc = sort_dir.eq_ignore_ascii_case("desc");

        // Dynamic sorting based on field name
        let results = match sort_field {
<%_ for (const field of fields.filter(f => !f.id)) { _%>
<%_ const patterns = field.fieldName === field.fieldNameUnderscored ? `"${field.fieldName}"` : `"${field.fieldName}" | "${field.fieldNameUnderscored}"`; _%>
            <%- patterns %> => {
                if is_desc {
                    <%= entityTableName %>::table
                        .order(<%= entityTableName %>::<%= field.fieldNameUnderscored %>.desc())
                        .limit(size)
                        .offset(offset)
                        .load::<<%= persistClass %>>(conn)
                } else {
                    <%= entityTableName %>::table
                        .order(<%= entityTableName %>::<%= field.fieldNameUnderscored %>.asc())
                        .limit(size)
                        .offset(offset)
                        .load::<<%= persistClass %>>(conn)
                }
            }
<%_ } _%>
            "createdDate" | "created_date" => {
                if is_desc {
                    <%= entityTableName %>::table
                        .order(<%= entityTableName %>::created_date.desc())
                        .limit(size)
                        .offset(offset)
                        .load::<<%= persistClass %>>(conn)
                } else {
                    <%= entityTableName %>::table
                        .order(<%= entityTableName %>::created_date.asc())
                        .limit(size)
                        .offset(offset)
                        .load::<<%= persistClass %>>(conn)
                }
            }
            "lastModifiedDate" | "last_modified_date" => {
                if is_desc {
                    <%= entityTableName %>::table
                        .order(<%= entityTableName %>::last_modified_date.desc())
                        .limit(size)
                        .offset(offset)
                        .load::<<%= persistClass %>>(conn)
                } else {
                    <%= entityTableName %>::table
                        .order(<%= entityTableName %>::last_modified_date.asc())
                        .limit(size)
                        .offset(offset)
                        .load::<<%= persistClass %>>(conn)
                }
            }
            _ => {
                // Default: sort by id
                if is_desc {
                    <%= entityTableName %>::table
                        .order(<%= entityTableName %>::id.desc())
                        .limit(size)
                        .offset(offset)
                        .load::<<%= persistClass %>>(conn)
                } else {
                    <%= entityTableName %>::table
                        .order(<%= entityTableName %>::id.asc())
                        .limit(size)
                        .offset(offset)
                        .load::<<%= persistClass %>>(conn)
                }
            }
        }
        .map_err(|e| AppError::Internal(e.to_string()))?;

        Ok((results, total))
    }

    /// Find <%= entityInstance %> by ID
    pub fn find_by_id(conn: &mut DbConnection, id: i32) -> Result<<%= persistClass %>, AppError> {
        <%= entityTableName %>::table
            .find(id)
            .first::<<%= persistClass %>>(conn)
            .map_err(|e| match e {
                diesel::result::Error::NotFound => {
                    AppError::NotFound(format!("<%= entityClass %> {} not found", id))
                }
                _ => AppError::Internal(e.to_string()),
            })
    }

    /// Create a new <%= entityInstance %>
    pub fn create(
        conn: &mut DbConnection,
        dto: Create<%= entityClass %>Dto,
        created_by: &str,
    ) -> Result<<%= persistClass %>, AppError> {
        let now = Utc::now().naive_utc();

        let new_entity = New<%= persistClass %> {
<%_ for (const field of fields.filter(f => !f.id)) { _%>
            <%= field.fieldNameUnderscored %>: dto.<%= field.fieldNameUnderscored %>,
<%_ } _%>
<%_ for (const relationship of relationships.filter(r => r.relationshipType === 'many-to-one' || (r.relationshipType === 'one-to-one' && r.ownerSide))) { _%>
            <%= relationship.relationshipFieldName %>_id: dto.<%= relationship.relationshipFieldName %>_id,
<%_ } _%>
            created_by: Some(created_by.to_string()),
            created_date: Some(now),
            last_modified_by: Some(created_by.to_string()),
            last_modified_date: Some(now),
        };

<%_ if (devDatabaseTypePostgresql) { _%>
        let entity = diesel::insert_into(<%= entityTableName %>::table)
            .values(&new_entity)
            .get_result::<<%= persistClass %>>(conn)
            .map_err(|e| AppError::Internal(e.to_string()))?;

        Ok(entity)
<%_ } else if (devDatabaseTypeMysql) { _%>
        diesel::insert_into(<%= entityTableName %>::table)
            .values(&new_entity)
            .execute(conn)
            .map_err(|e| AppError::Internal(e.to_string()))?;

        // MySQL doesn't support RETURNING, so we need to query for the inserted record
        let id = diesel::select(diesel::dsl::sql::<diesel::sql_types::Integer>("LAST_INSERT_ID()"))
            .get_result::<i32>(conn)
            .map_err(|e| AppError::Internal(e.to_string()))?;

        Self::find_by_id(conn, id)
<%_ } else { _%>
        diesel::insert_into(<%= entityTableName %>::table)
            .values(&new_entity)
            .execute(conn)
            .map_err(|e| AppError::Internal(e.to_string()))?;

        // SQLite doesn't support RETURNING, so we need to query for the inserted record
        let id = diesel::select(diesel::dsl::sql::<diesel::sql_types::Integer>("last_insert_rowid()"))
            .get_result::<i32>(conn)
            .map_err(|e| AppError::Internal(e.to_string()))?;

        Self::find_by_id(conn, id)
<%_ } _%>
    }

    /// Update an existing <%= entityInstance %>
    pub fn update(
        conn: &mut DbConnection,
        id: i32,
        dto: Update<%= entityClass %>Dto,
        modified_by: &str,
    ) -> Result<<%= persistClass %>, AppError> {
        let now = Utc::now().naive_utc();

        let update = Update<%= persistClass %> {
<%_ for (const field of fields.filter(f => !f.id)) { _%>
            <%= field.fieldNameUnderscored %>: dto.<%= field.fieldNameUnderscored %>,
<%_ } _%>
<%_ for (const relationship of relationships.filter(r => r.relationshipType === 'many-to-one' || (r.relationshipType === 'one-to-one' && r.ownerSide))) { _%>
            <%= relationship.relationshipFieldName %>_id: dto.<%= relationship.relationshipFieldName %>_id.map(Some),
<%_ } _%>
            last_modified_by: Some(modified_by.to_string()),
            last_modified_date: Some(now),
        };

        diesel::update(<%= entityTableName %>::table.find(id))
            .set(&update)
            .execute(conn)
            .map_err(|e| AppError::Internal(e.to_string()))?;

        Self::find_by_id(conn, id)
    }

    /// Delete a <%= entityInstance %>
    pub fn delete(conn: &mut DbConnection, id: i32) -> Result<(), AppError> {
        diesel::delete(<%= entityTableName %>::table.find(id))
            .execute(conn)
            .map_err(|e| AppError::Internal(e.to_string()))?;

        Ok(())
    }
<%_ for (const rel of manyToOneRels) { _%>

    /// Find related <%= rel.relationshipFieldName %> by ID
    pub fn find_<%= rel.relationshipFieldName %>_by_id(conn: &mut DbConnection, id: i32) -> Result<Option<<%= rel.otherEntity.persistClass %>>, AppError> {
        <%= rel.otherEntityTableName %>::table
            .find(id)
            .first::<<%= rel.otherEntity.persistClass %>>(conn)
            .optional()
            .map_err(|e| AppError::Internal(e.to_string()))
    }
<%_ } _%>
<%_ for (const rel of manyToManyOwnerRels) { _%>

    /// Add a <%= rel.otherEntity.entityInstance %> to this <%= entityInstance %>
    pub fn add_<%= rel.otherEntityName %>(
        conn: &mut DbConnection,
        <%= entityTableName %>_id: i32,
        <%= rel.otherEntityTableName %>_id: i32,
    ) -> Result<(), AppError> {
        let entry = <%= persistClass %><%= rel.otherEntity.persistClass %> {
            <%= entityTableName %>_id,
            <%= rel.otherEntityTableName %>_id,
        };

        diesel::insert_into(<%= rel.joinTable.name %>::table)
            .values(&entry)
            .execute(conn)
            .map_err(|e| AppError::Internal(e.to_string()))?;

        Ok(())
    }

    /// Remove a <%= rel.otherEntity.entityInstance %> from this <%= entityInstance %>
    pub fn remove_<%= rel.otherEntityName %>(
        conn: &mut DbConnection,
        <%= entityTableName %>_id: i32,
        <%= rel.otherEntityTableName %>_id: i32,
    ) -> Result<(), AppError> {
        diesel::delete(
            <%= rel.joinTable.name %>::table
                .filter(<%= rel.joinTable.name %>::<%= entityTableName %>_id.eq(<%= entityTableName %>_id))
                .filter(<%= rel.joinTable.name %>::<%= rel.otherEntityTableName %>_id.eq(<%= rel.otherEntityTableName %>_id)),
        )
        .execute(conn)
        .map_err(|e| AppError::Internal(e.to_string()))?;

        Ok(())
    }

    /// Get all <%= rel.otherEntity.entityInstancePlural %> for a <%= entityInstance %>
    pub fn get_<%= rel.otherEntity.entityInstancePlural %>(
        conn: &mut DbConnection,
        <%= entityTableName %>_id: i32,
    ) -> Result<Vec<<%= rel.otherEntity.persistClass %>>, AppError> {
        let <%= rel.otherEntityTableName %>_ids: Vec<i32> = <%= rel.joinTable.name %>::table
            .filter(<%= rel.joinTable.name %>::<%= entityTableName %>_id.eq(<%= entityTableName %>_id))
            .select(<%= rel.joinTable.name %>::<%= rel.otherEntityTableName %>_id)
            .load(conn)
            .map_err(|e| AppError::Internal(e.to_string()))?;

        <%= rel.otherEntityTableName %>::table
            .filter(<%= rel.otherEntityTableName %>::id.eq_any(<%= rel.otherEntityTableName %>_ids))
            .load::<<%= rel.otherEntity.persistClass %>>(conn)
            .map_err(|e| AppError::Internal(e.to_string()))
    }

    /// Sync <%= rel.otherEntity.entityInstancePlural %> for a <%= entityInstance %> - replaces all existing relationships
    pub fn sync_<%= rel.otherEntity.entityInstancePlural %>(
        conn: &mut DbConnection,
        <%= entityTableName %>_id: i32,
        <%= rel.otherEntityTableName %>_ids: Vec<i32>,
    ) -> Result<(), AppError> {
        // First, remove all existing relationships
        diesel::delete(
            <%= rel.joinTable.name %>::table
                .filter(<%= rel.joinTable.name %>::<%= entityTableName %>_id.eq(<%= entityTableName %>_id)),
        )
        .execute(conn)
        .map_err(|e| AppError::Internal(e.to_string()))?;

        // Then, add all new relationships
        for <%= rel.otherEntityTableName %>_id in <%= rel.otherEntityTableName %>_ids {
            let entry = <%= persistClass %><%= rel.otherEntity.persistClass %> {
                <%= entityTableName %>_id,
                <%= rel.otherEntityTableName %>_id,
            };

            diesel::insert_into(<%= rel.joinTable.name %>::table)
                .values(&entry)
                .execute(conn)
                .map_err(|e| AppError::Internal(e.to_string()))?;
        }

        Ok(())
    }
<%_ } _%>
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::test_utils::create_test_pool;
    use crate::dto::PageRequest;
    use std::sync::atomic::{AtomicU32, Ordering};

    static TEST_COUNTER: AtomicU32 = AtomicU32::new(0);

    fn create_test_dto_with_suffix(suffix: u32) -> Create<%= entityClass %>Dto {
        let _ = suffix; // Suppress unused warning when there are no String fields
        Create<%= entityClass %>Dto {
<%_ const allFields = fields.filter(f => !f.id); _%>
<%_ for (const field of allFields) { _%>
<%_ if (field.fieldValidationRequired) { _%>
<%_ if (field.fieldType === 'String' || field.fieldType === 'TextBlob') { _%>
            <%= field.fieldNameUnderscored %>: format!("test_value_{}", suffix),
<%_ } else if (field.fieldType === 'Integer') { _%>
            <%= field.fieldNameUnderscored %>: 1,
<%_ } else if (field.fieldType === 'Long') { _%>
            <%= field.fieldNameUnderscored %>: 1,
<%_ } else if (field.fieldType === 'Float') { _%>
            <%= field.fieldNameUnderscored %>: 1.0,
<%_ } else if (field.fieldType === 'Double') { _%>
            <%= field.fieldNameUnderscored %>: 1.0,
<%_ } else if (field.fieldType === 'Boolean') { _%>
            <%= field.fieldNameUnderscored %>: true,
<%_ } else if (field.fieldType === 'Instant' || field.fieldType === 'ZonedDateTime') { _%>
            <%= field.fieldNameUnderscored %>: chrono::NaiveDateTime::parse_from_str("2024-01-01 00:00:00", "%Y-%m-%d %H:%M:%S").unwrap(),
<%_ } else if (field.fieldType === 'LocalDate') { _%>
            <%= field.fieldNameUnderscored %>: chrono::NaiveDate::from_ymd_opt(2024, 1, 1).unwrap(),
<%_ } else { _%>
            <%= field.fieldNameUnderscored %>: format!("test_value_{}", suffix),
<%_ } _%>
<%_ } else { _%>
            <%= field.fieldNameUnderscored %>: None,
<%_ } _%>
<%_ } _%>
<%_ for (const relationship of relationships.filter(r => r.relationshipType === 'many-to-one' || (r.relationshipType === 'one-to-one' && r.ownerSide))) { _%>
            <%= relationship.relationshipFieldName %>_id: None,
<%_ } _%>
<%_ for (const rel of manyToManyOwnerRels) { _%>
            <%= rel.relationshipFieldNamePlural %>: None,
<%_ } _%>
        }
    }

    fn create_test_dto() -> Create<%= entityClass %>Dto {
        let suffix = TEST_COUNTER.fetch_add(1, Ordering::SeqCst);
        create_test_dto_with_suffix(suffix)
    }

    #[test]
    fn test_create_<%= entityInstance %>() {
        let pool = create_test_pool();
        let mut conn = pool.get().unwrap();

        let dto = create_test_dto();
        let result = <%= entityClass %>Service::create(&mut conn, dto, "test_user");

        assert!(result.is_ok());
        let entity = result.unwrap();
        assert!(entity.id > 0);
    }

    #[test]
    fn test_find_by_id() {
        let pool = create_test_pool();
        let mut conn = pool.get().unwrap();

        // Create an entity first
        let dto = create_test_dto();
        let created = <%= entityClass %>Service::create(&mut conn, dto, "test_user").unwrap();

        // Find it by ID
        let result = <%= entityClass %>Service::find_by_id(&mut conn, created.id);
        assert!(result.is_ok());
        let found = result.unwrap();
        assert_eq!(found.id, created.id);
    }

    #[test]
    fn test_find_by_id_not_found() {
        let pool = create_test_pool();
        let mut conn = pool.get().unwrap();

        let result = <%= entityClass %>Service::find_by_id(&mut conn, 99999);
        assert!(result.is_err());
    }

    #[test]
    fn test_find_all() {
        let pool = create_test_pool();
        let mut conn = pool.get().unwrap();

        // Create a few entities with unique values
        for _ in 0..3 {
            let dto = create_test_dto();
            <%= entityClass %>Service::create(&mut conn, dto, "test_user").unwrap();
        }

        let page_request = PageRequest {
            page: Some(0),
            size: Some(10),
            sort: Vec::new(),
        };

        let result = <%= entityClass %>Service::find_all(&mut conn, &page_request);
        assert!(result.is_ok());
        let (items, total) = result.unwrap();
        assert!(items.len() >= 3);
        assert!(total >= 3);
    }

    #[test]
    fn test_find_all_with_pagination() {
        let pool = create_test_pool();
        let mut conn = pool.get().unwrap();

        // Create 5 entities with unique values
        for _ in 0..5 {
            let dto = create_test_dto();
            <%= entityClass %>Service::create(&mut conn, dto, "test_user").unwrap();
        }

        // Request page 0 with size 2
        let page_request = PageRequest {
            page: Some(0),
            size: Some(2),
            sort: Vec::new(),
        };

        let result = <%= entityClass %>Service::find_all(&mut conn, &page_request);
        assert!(result.is_ok());
        let (items, _total) = result.unwrap();
        assert_eq!(items.len(), 2);
    }

    #[test]
    fn test_update_<%= entityInstance %>() {
        let pool = create_test_pool();
        let mut conn = pool.get().unwrap();

        // Create an entity
        let dto = create_test_dto();
        let created = <%= entityClass %>Service::create(&mut conn, dto, "test_user").unwrap();

        // Update it
        let update_dto = Update<%= entityClass %>Dto {
<%_ for (const field of allFields) { _%>
<%_ if (field.fieldType === 'String' || field.fieldType === 'TextBlob') { _%>
            <%= field.fieldNameUnderscored %>: Some("updated_value".to_string()),
<%_ } else if (field.fieldType === 'Integer') { _%>
            <%= field.fieldNameUnderscored %>: Some(999),
<%_ } else if (field.fieldType === 'Long') { _%>
            <%= field.fieldNameUnderscored %>: Some(999),
<%_ } else if (field.fieldType === 'Float') { _%>
            <%= field.fieldNameUnderscored %>: Some(999.99),
<%_ } else if (field.fieldType === 'Double') { _%>
            <%= field.fieldNameUnderscored %>: Some(999.99),
<%_ } else if (field.fieldType === 'Boolean') { _%>
            <%= field.fieldNameUnderscored %>: Some(true),
<%_ } else if (field.fieldType === 'Instant' || field.fieldType === 'ZonedDateTime') { _%>
            <%= field.fieldNameUnderscored %>: Some(chrono::NaiveDateTime::parse_from_str("2024-06-15 12:00:00", "%Y-%m-%d %H:%M:%S").unwrap()),
<%_ } else if (field.fieldType === 'LocalDate') { _%>
            <%= field.fieldNameUnderscored %>: Some(chrono::NaiveDate::from_ymd_opt(2024, 6, 15).unwrap()),
<%_ } else { _%>
            <%= field.fieldNameUnderscored %>: Some("updated_value".to_string()),
<%_ } _%>
<%_ } _%>
<%_ for (const relationship of relationships.filter(r => r.relationshipType === 'many-to-one' || (r.relationshipType === 'one-to-one' && r.ownerSide))) { _%>
            <%= relationship.relationshipFieldName %>_id: None,
<%_ } _%>
<%_ for (const rel of manyToManyOwnerRels) { _%>
            <%= rel.relationshipFieldNamePlural %>: None,
<%_ } _%>
        };

        let result = <%= entityClass %>Service::update(&mut conn, created.id, update_dto, "test_user");
        assert!(result.is_ok());
    }

    #[test]
    fn test_delete_<%= entityInstance %>() {
        let pool = create_test_pool();
        let mut conn = pool.get().unwrap();

        // Create an entity
        let dto = create_test_dto();
        let created = <%= entityClass %>Service::create(&mut conn, dto, "test_user").unwrap();

        // Delete it
        let result = <%= entityClass %>Service::delete(&mut conn, created.id);
        assert!(result.is_ok());

        // Verify it's gone
        let find_result = <%= entityClass %>Service::find_by_id(&mut conn, created.id);
        assert!(find_result.is_err());
    }
<%_ for (const rel of manyToManyOwnerRels) { _%>

    #[test]
    fn test_add_<%= rel.otherEntityName %>_to_<%= entityInstance %>() {
        let pool = create_test_pool();
        let mut conn = pool.get().unwrap();

        // Create a <%= entityInstance %>
        let dto = create_test_dto();
        let <%= entityInstance %> = <%= entityClass %>Service::create(&mut conn, dto, "test_user").unwrap();

        // Create a <%= rel.otherEntity.entityInstance %>
        let <%= rel.otherEntity.entityInstance %>_dto = crate::dto::Create<%= rel.otherEntity.entityClass %>Dto {
<%_ for (let i = 0; i < rel.otherEntity.fields.filter(f => !f.id).length; i++) { _%>
<%_ const field = rel.otherEntity.fields.filter(f => !f.id)[i]; _%>
<%_ const isLast = i === rel.otherEntity.fields.filter(f => !f.id).length - 1; _%>
            <%= field.fieldNameUnderscored %>: None<% if (!isLast) { %>,<% } %>
<%_ } _%>
        };
        let <%= rel.otherEntity.entityInstance %> = crate::services::<%= rel.otherEntity.entityClass %>Service::create(&mut conn, <%= rel.otherEntity.entityInstance %>_dto, "test_user").unwrap();

        // Add relationship
        let result = <%= entityClass %>Service::add_<%= rel.otherEntityName %>(&mut conn, <%= entityInstance %>.id, <%= rel.otherEntity.entityInstance %>.id);
        assert!(result.is_ok());

        // Verify relationship exists
        let <%= rel.otherEntity.entityInstancePlural %> = <%= entityClass %>Service::get_<%= rel.otherEntity.entityInstancePlural %>(&mut conn, <%= entityInstance %>.id).unwrap();
        assert_eq!(<%= rel.otherEntity.entityInstancePlural %>.len(), 1);
        assert_eq!(<%= rel.otherEntity.entityInstancePlural %>[0].id, <%= rel.otherEntity.entityInstance %>.id);
    }

    #[test]
    fn test_remove_<%= rel.otherEntityName %>_from_<%= entityInstance %>() {
        let pool = create_test_pool();
        let mut conn = pool.get().unwrap();

        // Create a <%= entityInstance %>
        let dto = create_test_dto();
        let <%= entityInstance %> = <%= entityClass %>Service::create(&mut conn, dto, "test_user").unwrap();

        // Create a <%= rel.otherEntity.entityInstance %>
        let <%= rel.otherEntity.entityInstance %>_dto = crate::dto::Create<%= rel.otherEntity.entityClass %>Dto {
<%_ for (let i = 0; i < rel.otherEntity.fields.filter(f => !f.id).length; i++) { _%>
<%_ const field = rel.otherEntity.fields.filter(f => !f.id)[i]; _%>
<%_ const isLast = i === rel.otherEntity.fields.filter(f => !f.id).length - 1; _%>
            <%= field.fieldNameUnderscored %>: None<% if (!isLast) { %>,<% } %>
<%_ } _%>
        };
        let <%= rel.otherEntity.entityInstance %> = crate::services::<%= rel.otherEntity.entityClass %>Service::create(&mut conn, <%= rel.otherEntity.entityInstance %>_dto, "test_user").unwrap();

        // Add relationship
        <%= entityClass %>Service::add_<%= rel.otherEntityName %>(&mut conn, <%= entityInstance %>.id, <%= rel.otherEntity.entityInstance %>.id).unwrap();

        // Remove relationship
        let result = <%= entityClass %>Service::remove_<%= rel.otherEntityName %>(&mut conn, <%= entityInstance %>.id, <%= rel.otherEntity.entityInstance %>.id);
        assert!(result.is_ok());

        // Verify relationship is gone
        let <%= rel.otherEntity.entityInstancePlural %> = <%= entityClass %>Service::get_<%= rel.otherEntity.entityInstancePlural %>(&mut conn, <%= entityInstance %>.id).unwrap();
        assert_eq!(<%= rel.otherEntity.entityInstancePlural %>.len(), 0);
    }

    #[test]
    fn test_get_<%= rel.otherEntity.entityInstancePlural %>_empty() {
        let pool = create_test_pool();
        let mut conn = pool.get().unwrap();

        // Create a <%= entityInstance %> with no relationships
        let dto = create_test_dto();
        let <%= entityInstance %> = <%= entityClass %>Service::create(&mut conn, dto, "test_user").unwrap();

        // Verify no relationships
        let <%= rel.otherEntity.entityInstancePlural %> = <%= entityClass %>Service::get_<%= rel.otherEntity.entityInstancePlural %>(&mut conn, <%= entityInstance %>.id).unwrap();
        assert_eq!(<%= rel.otherEntity.entityInstancePlural %>.len(), 0);
    }
<%_ } _%>
}
