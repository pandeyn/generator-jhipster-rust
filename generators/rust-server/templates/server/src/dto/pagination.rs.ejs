use axum::{
    async_trait,
    extract::FromRequestParts,
    http::{request::Parts, StatusCode},
    response::{IntoResponse, Response},
};
use serde::{de::DeserializeOwned, Deserialize, Deserializer, Serialize};
<%_ if (enableSwaggerCodegen) { _%>
use utoipa::{IntoParams, ToSchema};
<%_ } _%>

/// Custom query extractor that uses serde_qs to properly handle repeated query parameters
/// like `sort=name,asc&sort=id,desc`
#[derive(Debug, Clone)]
pub struct QsQuery<T>(pub T);

#[async_trait]
impl<S, T> FromRequestParts<S> for QsQuery<T>
where
    S: Send + Sync,
    T: DeserializeOwned,
{
    type Rejection = QsQueryRejection;

    async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
        let query = parts.uri.query().unwrap_or_default();
        // Pre-process query string to convert duplicate keys to indexed array format
        // e.g., "sort=a&sort=b" becomes "sort[0]=a&sort[1]=b"
        let processed_query = preprocess_duplicate_keys(query);
        let config = serde_qs::Config::new(5, false);
        let value = config.deserialize_str(&processed_query).map_err(|e| QsQueryRejection(e.to_string()))?;
        Ok(QsQuery(value))
    }
}

/// Pre-process query string to convert duplicate keys to indexed array format
/// This allows serde_qs to properly deserialize duplicate keys like "sort=a&sort=b"
/// into a Vec by converting them to "sort[0]=a&sort[1]=b"
fn preprocess_duplicate_keys(query: &str) -> String {
    use std::collections::HashMap;

    let mut key_counts: HashMap<&str, usize> = HashMap::new();
    let mut result_pairs: Vec<String> = Vec::new();

    for pair in query.split('&') {
        if pair.is_empty() {
            continue;
        }

        if let Some((key, value)) = pair.split_once('=') {
            let count = key_counts.entry(key).or_insert(0);
            if *count == 0 {
                // First occurrence - check if there are more of this key
                let occurrences = query.split('&')
                    .filter(|p| p.starts_with(&format!("{}=", key)))
                    .count();
                if occurrences > 1 {
                    // Multiple occurrences - use indexed format
                    result_pairs.push(format!("{}[{}]={}", key, count, value));
                } else {
                    // Single occurrence - keep as-is
                    result_pairs.push(pair.to_string());
                }
            } else {
                // Subsequent occurrence - always use indexed format
                result_pairs.push(format!("{}[{}]={}", key, count, value));
            }
            *count += 1;
        } else {
            // No '=' in pair, keep as-is
            result_pairs.push(pair.to_string());
        }
    }

    result_pairs.join("&")
}

/// Rejection type for QsQuery extractor
pub struct QsQueryRejection(String);

impl IntoResponse for QsQueryRejection {
    fn into_response(self) -> Response {
        (
            StatusCode::BAD_REQUEST,
            format!("Failed to deserialize query string: {}", self.0),
        )
            .into_response()
    }
}

/// Deserialize sort parameter that can be either a single string or an array of strings
fn deserialize_sort<'de, D>(deserializer: D) -> Result<Vec<String>, D::Error>
where
    D: Deserializer<'de>,
{
    use serde::de::{self, Visitor};
    use std::fmt;

    struct SortVisitor;

    impl<'de> Visitor<'de> for SortVisitor {
        type Value = Vec<String>;

        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            formatter.write_str("a string or array of strings")
        }

        fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>
        where
            E: de::Error,
        {
            Ok(vec![value.to_string()])
        }

        fn visit_string<E>(self, value: String) -> Result<Self::Value, E>
        where
            E: de::Error,
        {
            Ok(vec![value])
        }

        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
        where
            A: de::SeqAccess<'de>,
        {
            let mut vec = Vec::new();
            while let Some(value) = seq.next_element::<String>()? {
                vec.push(value);
            }
            Ok(vec)
        }

        fn visit_none<E>(self) -> Result<Self::Value, E>
        where
            E: de::Error,
        {
            Ok(Vec::new())
        }

        fn visit_unit<E>(self) -> Result<Self::Value, E>
        where
            E: de::Error,
        {
            Ok(Vec::new())
        }
    }

    deserializer.deserialize_any(SortVisitor)
}

/// Pagination request parameters
#[derive(Debug, Clone, Deserialize<%_ if (enableSwaggerCodegen) { _%>, IntoParams, ToSchema<%_ } _%>)]
pub struct PageRequest {
    /// Page number (0-indexed)
    pub page: Option<i64>,
    /// Number of items per page (max 100)
    pub size: Option<i64>,
    /// Sort parameters - can be a single value (sort=id,asc) or multiple (sort=name,asc&sort=id,desc)
    /// Each sort value is in format "field,direction" where direction is "asc" or "desc"
    #[serde(default, deserialize_with = "deserialize_sort")]
<%_ if (enableSwaggerCodegen) { _%>
    #[param(value_type = Option<String>)]
<%_ } _%>
    pub sort: Vec<String>,
}

impl PageRequest {
    pub fn offset(&self) -> i64 {
        let page = self.page.unwrap_or(0);
        let size = self.size.unwrap_or(20);
        page * size
    }

    pub fn limit(&self) -> i64 {
        self.size.unwrap_or(20).min(100)
    }

    /// Get the primary sort field and direction (first sort parameter)
    pub fn primary_sort(&self) -> Option<(&str, &str)> {
        self.sort.first().and_then(|s| {
            let parts: Vec<&str> = s.split(',').collect();
            if parts.len() >= 2 {
                Some((parts[0], parts[1]))
            } else if parts.len() == 1 {
                Some((parts[0], "asc"))
            } else {
                None
            }
        })
    }

    /// Get all sort parameters as (field, direction) tuples
    pub fn sort_params(&self) -> Vec<(&str, &str)> {
        self.sort
            .iter()
            .filter_map(|s| {
                let parts: Vec<&str> = s.split(',').collect();
                if parts.len() >= 2 {
                    Some((parts[0], parts[1]))
                } else if parts.len() == 1 {
                    Some((parts[0], "asc"))
                } else {
                    None
                }
            })
            .collect()
    }
}

impl Default for PageRequest {
    fn default() -> Self {
        Self {
            page: Some(0),
            size: Some(20),
            sort: Vec::new(),
        }
    }
}

/// Paginated response
#[derive(Debug, Clone, Serialize<%_ if (enableSwaggerCodegen) { _%>, ToSchema<%_ } _%>)]
#[serde(rename_all = "camelCase")]
pub struct PageResponse<T> {
    /// List of items on this page
    pub content: Vec<T>,
    /// Total number of items across all pages
    pub total_elements: i64,
    /// Current page number (0-indexed)
    pub page: i64,
    /// Number of items per page
    pub size: i64,
}

impl<T> PageResponse<T> {
    pub fn new(content: Vec<T>, total_elements: i64, page: i64, size: i64) -> Self {
        Self {
            content,
            total_elements,
            page,
            size,
        }
    }

    pub fn total_pages(&self) -> i64 {
        if self.size == 0 {
            0
        } else {
            (self.total_elements + self.size - 1) / self.size
        }
    }

    pub fn has_next(&self) -> bool {
        self.page < self.total_pages() - 1
    }

    pub fn has_previous(&self) -> bool {
        self.page > 0
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    mod page_request_tests {
        use super::*;

        #[test]
        fn test_default_page_request() {
            let request = PageRequest::default();
            assert_eq!(request.page, Some(0));
            assert_eq!(request.size, Some(20));
            assert!(request.sort.is_empty());
        }

        #[test]
        fn test_offset_calculation() {
            let request = PageRequest {
                page: Some(2),
                size: Some(10),
                sort: Vec::new(),
            };
            assert_eq!(request.offset(), 20);
        }

        #[test]
        fn test_offset_with_defaults() {
            let request = PageRequest {
                page: None,
                size: None,
                sort: Vec::new(),
            };
            assert_eq!(request.offset(), 0);
        }

        #[test]
        fn test_limit_respects_max() {
            let request = PageRequest {
                page: Some(0),
                size: Some(200),
                sort: Vec::new(),
            };
            assert_eq!(request.limit(), 100);
        }

        #[test]
        fn test_limit_with_default() {
            let request = PageRequest {
                page: Some(0),
                size: None,
                sort: Vec::new(),
            };
            assert_eq!(request.limit(), 20);
        }

        #[test]
        fn test_primary_sort_with_direction() {
            let request = PageRequest {
                page: Some(0),
                size: Some(20),
                sort: vec!["name,asc".to_string(), "id,desc".to_string()],
            };
            assert_eq!(request.primary_sort(), Some(("name", "asc")));
        }

        #[test]
        fn test_primary_sort_without_direction() {
            let request = PageRequest {
                page: Some(0),
                size: Some(20),
                sort: vec!["name".to_string()],
            };
            assert_eq!(request.primary_sort(), Some(("name", "asc")));
        }

        #[test]
        fn test_primary_sort_empty() {
            let request = PageRequest::default();
            assert_eq!(request.primary_sort(), None);
        }

        #[test]
        fn test_sort_params_multiple() {
            let request = PageRequest {
                page: Some(0),
                size: Some(20),
                sort: vec!["email,asc".to_string(), "id,desc".to_string()],
            };
            let params = request.sort_params();
            assert_eq!(params.len(), 2);
            assert_eq!(params[0], ("email", "asc"));
            assert_eq!(params[1], ("id", "desc"));
        }
    }

    mod page_response_tests {
        use super::*;

        #[test]
        fn test_new_page_response() {
            let response: PageResponse<i32> = PageResponse::new(vec![1, 2, 3], 100, 0, 20);
            assert_eq!(response.content.len(), 3);
            assert_eq!(response.total_elements, 100);
            assert_eq!(response.page, 0);
            assert_eq!(response.size, 20);
        }

        #[test]
        fn test_total_pages_calculation() {
            let response: PageResponse<i32> = PageResponse::new(vec![], 100, 0, 20);
            assert_eq!(response.total_pages(), 5);
        }

        #[test]
        fn test_total_pages_with_remainder() {
            let response: PageResponse<i32> = PageResponse::new(vec![], 101, 0, 20);
            assert_eq!(response.total_pages(), 6);
        }

        #[test]
        fn test_total_pages_zero_size() {
            let response: PageResponse<i32> = PageResponse::new(vec![], 100, 0, 0);
            assert_eq!(response.total_pages(), 0);
        }

        #[test]
        fn test_has_next_true() {
            let response: PageResponse<i32> = PageResponse::new(vec![], 100, 0, 20);
            assert!(response.has_next());
        }

        #[test]
        fn test_has_next_false_on_last_page() {
            let response: PageResponse<i32> = PageResponse::new(vec![], 100, 4, 20);
            assert!(!response.has_next());
        }

        #[test]
        fn test_has_previous_false_on_first_page() {
            let response: PageResponse<i32> = PageResponse::new(vec![], 100, 0, 20);
            assert!(!response.has_previous());
        }

        #[test]
        fn test_has_previous_true() {
            let response: PageResponse<i32> = PageResponse::new(vec![], 100, 2, 20);
            assert!(response.has_previous());
        }
    }
}
