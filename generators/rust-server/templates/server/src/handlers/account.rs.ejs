use axum::{
<%_ if (enableEmail) { _%>
    extract::{State, Query},
<%_ } else { _%>
    extract::State,
<%_ } _%>
<%_ if (authenticationTypeJwt) { _%>
    http::{header, StatusCode},
    response::{IntoResponse, Response},
    routing::{get, post},
<%_ } else { _%>
    http::StatusCode,
    routing::get,
<%_ } _%>
    Extension, Json, Router,
};
<%_ if (authenticationTypeJwt) { _%>
use serde::{Deserialize, Serialize};
<%_ } else { _%>
use serde::Deserialize;
<%_ } _%>
<%_ if (enableSwaggerCodegen) { _%>
use utoipa::ToSchema;
<%_ } _%>

use crate::dto::UserDto;
use crate::errors::AppError;
use crate::middleware::auth::AuthUser;
<%_ if (authenticationTypeJwt) { _%>
use crate::services::{AuthService, UserService};
<%_ } else { _%>
use crate::services::UserService;
<%_ } _%>
use crate::AppState;

/// Account routes (current user)
pub fn routes() -> Router<AppState> {
    Router::new()
        .route("/", get(get_account).post(save_account))
<%_ if (authenticationTypeJwt) { _%>
        .route("/change-password", post(change_password))
<%_ if (enableEmail) { _%>
        .route("/reset-password/init", post(reset_password_init))
        .route("/reset-password/finish", post(reset_password_finish))
<%_ } _%>
<%_ } _%>
}

<%_ if (authenticationTypeJwt) { _%>
/// Public account routes (no authentication required)
pub fn public_routes() -> Router<AppState> {
    Router::new()
        .route("/register", post(register))
<%_ if (enableEmail) { _%>
        .route("/activate", get(activate))
<%_ } _%>
}

/// Password length constraints (matching Spring Boot JHipster)
const PASSWORD_MIN_LENGTH: usize = 4;
const PASSWORD_MAX_LENGTH: usize = 100;

/// Check if password length is invalid
fn is_password_length_invalid(password: &str) -> bool {
    password.is_empty() || password.len() < PASSWORD_MIN_LENGTH || password.len() > PASSWORD_MAX_LENGTH
}

/// Registration request (matches Spring Boot ManagedUserVM)
#[derive(Debug, Deserialize<%_ if (enableSwaggerCodegen) { _%>, ToSchema<%_ } _%>)]
#[serde(rename_all = "camelCase")]
pub struct RegisterRequest {
    /// Username (login)
    pub login: String,
    /// Email address
    pub email: String,
    /// Password (4-100 characters)
    pub password: String,
    /// Language key
    #[serde(default)]
    pub lang_key: Option<String>,
}
<%_ } _%>

<%_ if (authenticationTypeJwt) { _%>
/// Authentication routes
pub fn auth_routes() -> Router<AppState> {
    Router::new().route("/", post(authenticate))
}

#[derive(Debug, Deserialize<%_ if (enableSwaggerCodegen) { _%>, ToSchema<%_ } _%>)]
pub struct LoginRequest {
    /// Username (login)
    pub username: String,
    /// Password
    pub password: String,
    /// Remember me flag for extended session
    #[serde(default)]
    pub remember_me: bool,
}

#[derive(Debug, Serialize<%_ if (enableSwaggerCodegen) { _%>, ToSchema<%_ } _%>)]
pub struct LoginResponse {
    /// JWT authentication token
    pub id_token: String,
}

#[derive(Debug, Deserialize<%_ if (enableSwaggerCodegen) { _%>, ToSchema<%_ } _%>)]
#[serde(rename_all = "camelCase")]
pub struct ChangePasswordRequest {
    /// Current password for verification
    pub current_password: String,
    /// New password to set
    pub new_password: String,
}

/// Request body for saving account settings (matches Angular Account model)
#[derive(Debug, Deserialize<%_ if (enableSwaggerCodegen) { _%>, ToSchema<%_ } _%>)]
#[serde(rename_all = "camelCase")]
pub struct SaveAccountRequest {
    /// First name
    pub first_name: Option<String>,
    /// Last name
    pub last_name: Option<String>,
    /// Email address
    pub email: String,
    /// Language key
    pub lang_key: Option<String>,
    /// Image URL
    pub image_url: Option<String>,
}

/// Authenticate user and return JWT token
/// Returns token in both Authorization header (for JHipster React) and response body
<%_ if (enableSwaggerCodegen) { _%>
#[utoipa::path(
    post,
    path = "/api/authenticate",
    tag = "authentication",
    request_body = LoginRequest,
    responses(
        (status = 200, description = "Authentication successful", body = LoginResponse,
            headers(
                ("Authorization" = String, description = "Bearer token")
            )
        ),
        (status = 400, description = "Missing username or password"),
        (status = 401, description = "Invalid credentials")
    )
)]
<%_ } _%>
pub async fn authenticate(
    State(state): State<AppState>,
    Json(login): Json<LoginRequest>,
) -> Result<Response, AppError> {
    // Validate required fields - return 400 for missing credentials (matching Spring Boot)
    if login.username.is_empty() {
        return Err(AppError::BadRequest("Username is required".to_string()));
    }
    if login.password.is_empty() {
        return Err(AppError::BadRequest("Password is required".to_string()));
    }

<%_ if (devDatabaseTypeMongodb) { _%>
    let token = AuthService::authenticate(
        &state.db,
        &state.config,
        &login.username,
        &login.password,
        login.remember_me,
    ).await?;
<%_ } else { _%>
    let mut conn = state.pool.get().map_err(|e| AppError::Internal(e.to_string()))?;

    let token = AuthService::authenticate(
        &mut conn,
        &state.config,
        &login.username,
        &login.password,
        login.remember_me,
    )?;
<%_ } _%>

    // Return token in both header and body for compatibility
    let response = (
        [(header::AUTHORIZATION, format!("Bearer {}", token))],
        Json(LoginResponse { id_token: token }),
    );

    Ok(response.into_response())
}
<%_ } _%>

/// Get current user's account
<%_ if (enableSwaggerCodegen) { _%>
#[utoipa::path(
    get,
    path = "/api/account",
    tag = "account",
    security(("bearer_auth" = [])),
    responses(
        (status = 200, description = "Current user account info", body = UserDto),
        (status = 401, description = "Not authenticated")
    )
)]
<%_ } _%>
<%_ if (authenticationTypeOauth2) { _%>
///
/// For OAuth2 authentication, returns user info from the validated token.
/// If the user exists in the local database, additional details are merged.
pub async fn get_account(
    State(state): State<AppState>,
    Extension(auth_user): Extension<AuthUser>,
) -> Result<Json<UserDto>, AppError> {
    // Check if user is authenticated (not anonymous)
    if auth_user.is_anonymous() {
        return Err(AppError::Unauthorized("Not authenticated".to_string()));
    }

<%_ if (devDatabaseTypeMongodb) { _%>
    // Try to find user in local database
    match UserService::find_by_login(&state.db, &auth_user.login).await {
        Ok(Some(user)) => {
            // User exists in DB - merge with token info
            let mut user_dto = UserDto::from(user);
            user_dto.authorities = Some(auth_user.authorities.clone());
            // Override with OAuth2 claims if available
            if let Some(email) = &auth_user.email {
                user_dto.email = email.clone();
            }
            if let Some(first_name) = &auth_user.first_name {
                user_dto.first_name = Some(first_name.clone());
            }
            if let Some(last_name) = &auth_user.last_name {
                user_dto.last_name = Some(last_name.clone());
            }
            Ok(Json(user_dto))
        }
        _ => {
            // User not in DB - return info from OAuth2 token only
            let user_dto = UserDto {
                id: None,
                login: auth_user.login.clone(),
                first_name: auth_user.first_name.clone(),
                last_name: auth_user.last_name.clone(),
                email: auth_user.email.clone().unwrap_or_else(|| format!("{}@localhost", auth_user.login)),
                image_url: None,
                activated: true,
                lang_key: Some("en".to_string()),
                authorities: Some(auth_user.authorities.clone()),
                created_by: None,
                created_date: None,
                last_modified_by: None,
                last_modified_date: None,
            };
            Ok(Json(user_dto))
        }
    }
<%_ } else { _%>
    let mut conn = state.pool.get().map_err(|e| AppError::Internal(e.to_string()))?;

    // Try to find user in local database
    match UserService::find_by_login(&mut conn, &auth_user.login) {
        Ok(user) => {
            // User exists in DB - merge with token info
            let mut user_dto = UserDto::from(user);
            user_dto.authorities = Some(auth_user.authorities.clone());
            // Override with OAuth2 claims if available
            if let Some(email) = &auth_user.email {
                user_dto.email = email.clone();
            }
            if let Some(first_name) = &auth_user.first_name {
                user_dto.first_name = Some(first_name.clone());
            }
            if let Some(last_name) = &auth_user.last_name {
                user_dto.last_name = Some(last_name.clone());
            }
            Ok(Json(user_dto))
        }
        Err(_) => {
            // User not in DB - return info from OAuth2 token only
            let user_dto = UserDto {
                id: None,
                login: auth_user.login.clone(),
                first_name: auth_user.first_name.clone(),
                last_name: auth_user.last_name.clone(),
                email: auth_user.email.clone().unwrap_or_else(|| format!("{}@localhost", auth_user.login)),
                image_url: None,
                activated: true,
                lang_key: Some("en".to_string()),
                authorities: Some(auth_user.authorities.clone()),
                created_by: None,
                created_date: None,
                last_modified_by: None,
                last_modified_date: None,
            };
            Ok(Json(user_dto))
        }
    }
<%_ } _%>
}

/// Request body for saving account settings (matches Angular Account model)
#[derive(Debug, Deserialize<%_ if (enableSwaggerCodegen) { _%>, ToSchema<%_ } _%>)]
#[serde(rename_all = "camelCase")]
pub struct SaveAccountRequest {
    /// First name
    pub first_name: Option<String>,
    /// Last name
    pub last_name: Option<String>,
    /// Email address
    pub email: String,
    /// Language key
    pub lang_key: Option<String>,
    /// Image URL
    pub image_url: Option<String>,
}

/// POST /api/account - Save current user's account settings
///
/// Matches Spring Boot JHipster AccountResource.saveAccount():
/// - Updates first name, last name, email, lang key, and image URL
/// - Returns 200 OK on success
/// - Returns 400 Bad Request if email is already in use by another user
<%_ if (enableSwaggerCodegen) { _%>
#[utoipa::path(
    post,
    path = "/api/account",
    tag = "account",
    security(("bearer_auth" = [])),
    request_body = SaveAccountRequest,
    responses(
        (status = 200, description = "Account saved successfully"),
        (status = 400, description = "Email already in use"),
        (status = 401, description = "Not authenticated")
    )
)]
<%_ } _%>
pub async fn save_account(
    State(state): State<AppState>,
    Extension(auth_user): Extension<AuthUser>,
    Json(request): Json<SaveAccountRequest>,
) -> Result<StatusCode, AppError> {
    // Check if user is authenticated (not anonymous)
    if auth_user.is_anonymous() {
        return Err(AppError::Unauthorized("Not authenticated".to_string()));
    }

<%_ if (devDatabaseTypeMongodb) { _%>
    // Check if email is already in use by another user
    if let Ok(Some(existing)) = UserService::find_by_email(&state.db, &request.email.to_lowercase()).await {
        if existing.login != auth_user.login {
            return Err(AppError::BadRequest("Email already in use".to_string()));
        }
    }

    // Update user account
    UserService::update_account(
        &state.db,
        &auth_user.login,
        request.first_name,
        request.last_name,
        request.email.to_lowercase(),
        request.lang_key,
        request.image_url,
    ).await?;
<%_ } else { _%>
    let mut conn = state.pool.get().map_err(|e| AppError::Internal(e.to_string()))?;

    // Check if email is already in use by another user
    if let Ok(existing) = UserService::find_by_email(&mut conn, &request.email.to_lowercase()) {
        if existing.login != auth_user.login {
            return Err(AppError::BadRequest("Email already in use".to_string()));
        }
    }

    // Update user account
    UserService::update_account(
        &mut conn,
        &auth_user.login,
        request.first_name,
        request.last_name,
        request.email.to_lowercase(),
        request.lang_key,
        request.image_url,
    )?;
<%_ } _%>

    Ok(StatusCode::OK)
}
<%_ } else { _%>
pub async fn get_account(
    State(state): State<AppState>,
    Extension(auth_user): Extension<AuthUser>,
) -> Result<Json<UserDto>, AppError> {
    // Check if user is authenticated (not anonymous)
    if auth_user.is_anonymous() {
        return Err(AppError::Unauthorized("Not authenticated".to_string()));
    }

<%_ if (devDatabaseTypeMongodb) { _%>
    let user = UserService::find_by_login(&state.db, &auth_user.login).await?
        .ok_or_else(|| AppError::NotFound(format!("User {} not found", auth_user.login)))?;

    // Include authorities from JWT in the response
    let mut user_dto = UserDto::from(user);
    user_dto.authorities = Some(auth_user.authorities.clone());
<%_ } else { _%>
    let mut conn = state.pool.get().map_err(|e| AppError::Internal(e.to_string()))?;

    let user = UserService::find_by_login(&mut conn, &auth_user.login)?;

    // Include authorities from JWT in the response
    let mut user_dto = UserDto::from(user);
    user_dto.authorities = Some(auth_user.authorities.clone());
<%_ } _%>

    Ok(Json(user_dto))
}

/// POST /api/account - Save current user's account settings
///
/// Matches Spring Boot JHipster AccountResource.saveAccount():
/// - Updates first name, last name, email, lang key, and image URL
/// - Returns 200 OK on success
/// - Returns 400 Bad Request if email is already in use by another user
<%_ if (enableSwaggerCodegen) { _%>
#[utoipa::path(
    post,
    path = "/api/account",
    tag = "account",
    security(("bearer_auth" = [])),
    request_body = SaveAccountRequest,
    responses(
        (status = 200, description = "Account saved successfully"),
        (status = 400, description = "Email already in use"),
        (status = 401, description = "Not authenticated")
    )
)]
<%_ } _%>
pub async fn save_account(
    State(state): State<AppState>,
    Extension(auth_user): Extension<AuthUser>,
    Json(request): Json<SaveAccountRequest>,
) -> Result<StatusCode, AppError> {
    // Check if user is authenticated (not anonymous)
    if auth_user.is_anonymous() {
        return Err(AppError::Unauthorized("Not authenticated".to_string()));
    }

<%_ if (devDatabaseTypeMongodb) { _%>
    // Check if email is already in use by another user
    if let Ok(Some(existing)) = UserService::find_by_email(&state.db, &request.email.to_lowercase()).await {
        if existing.login != auth_user.login {
            return Err(AppError::BadRequest("Email already in use".to_string()));
        }
    }

    // Update user account
    UserService::update_account(
        &state.db,
        &auth_user.login,
        request.first_name,
        request.last_name,
        request.email.to_lowercase(),
        request.lang_key,
        request.image_url,
    ).await?;
<%_ } else { _%>
    let mut conn = state.pool.get().map_err(|e| AppError::Internal(e.to_string()))?;

    // Check if email is already in use by another user
    if let Ok(existing) = UserService::find_by_email(&mut conn, &request.email.to_lowercase()) {
        if existing.login != auth_user.login {
            return Err(AppError::BadRequest("Email already in use".to_string()));
        }
    }

    // Update user account
    UserService::update_account(
        &mut conn,
        &auth_user.login,
        request.first_name,
        request.last_name,
        request.email.to_lowercase(),
        request.lang_key,
        request.image_url,
    )?;
<%_ } _%>

    Ok(StatusCode::OK)
}

/// Change current user's password
<%_ if (enableSwaggerCodegen) { _%>
#[utoipa::path(
    post,
    path = "/api/account/change-password",
    tag = "account",
    security(("bearer_auth" = [])),
    request_body = ChangePasswordRequest,
    responses(
        (status = 200, description = "Password changed successfully"),
        (status = 400, description = "Invalid current password"),
        (status = 401, description = "Not authenticated")
    )
)]
<%_ } _%>
pub async fn change_password(
    State(state): State<AppState>,
    Extension(auth_user): Extension<AuthUser>,
    Json(request): Json<ChangePasswordRequest>,
) -> Result<StatusCode, AppError> {
<%_ if (devDatabaseTypeMongodb) { _%>
    AuthService::change_password(
        &state.db,
        &auth_user.login,
        &request.current_password,
        &request.new_password,
    ).await?;
<%_ } else { _%>
    let mut conn = state.pool.get().map_err(|e| AppError::Internal(e.to_string()))?;

    AuthService::change_password(
        &mut conn,
        &auth_user.login,
        &request.current_password,
        &request.new_password,
    )?;
<%_ } _%>

    Ok(StatusCode::OK)
}
<%_ } _%>

<%_ if (authenticationTypeJwt) { _%>
/// POST /api/register - Register a new user account
///
/// Matches Spring Boot JHipster AccountResource.registerAccount():
/// - Returns 201 Created on success
/// - Returns 400 Bad Request for invalid password or duplicate login/email
<%_ if (enableEmail) { _%>
/// - Removes non-activated duplicate users (like Spring Boot)
/// - When email is enabled, creates inactive user and sends activation email
<%_ } else { _%>
/// - When email is disabled, creates already-activated user
<%_ } _%>
<%_ if (enableSwaggerCodegen) { _%>
#[utoipa::path(
    post,
    path = "/api/register",
    tag = "account",
    request_body = RegisterRequest,
    responses(
        (status = 201, description = "User registered successfully"),
        (status = 400, description = "Invalid password or duplicate login/email")
    )
)]
<%_ } _%>
pub async fn register(
    State(state): State<AppState>,
    Json(request): Json<RegisterRequest>,
) -> Result<StatusCode, AppError> {
    // Validate password length (matching Spring Boot)
    if is_password_length_invalid(&request.password) {
        return Err(AppError::BadRequest("Password must be between 4 and 100 characters".to_string()));
    }

<%_ if (devDatabaseTypeMongodb) { _%>
<%_ if (enableEmail) { _%>
    // Check login - remove non-activated duplicate, error if activated exists
    if let Ok(Some(existing)) = UserService::find_by_login(&state.db, &request.login.to_lowercase()).await {
        if existing.activated {
            return Err(AppError::BadRequest("Login already in use".to_string()));
        }
        // Remove non-activated user (like Spring Boot)
        if let Some(id) = existing.id {
            let _ = UserService::delete(&state.db, id).await;
        }
    }

    // Check email - remove non-activated duplicate, error if activated exists
    if let Ok(Some(existing)) = UserService::find_by_email_ignore_case(&state.db, &request.email).await {
        if existing.activated {
            return Err(AppError::BadRequest("Email already in use".to_string()));
        }
        // Remove non-activated user (like Spring Boot)
        if let Some(id) = existing.id {
            let _ = UserService::delete(&state.db, id).await;
        }
    }

    // Generate activation key
    let activation_key = generate_random_key();

    // Create user (not activated)
    let user = UserService::create_with_activation(
        &state.db,
        request.login.to_lowercase(),
        request.email.to_lowercase(),
        &request.password,
        request.lang_key.clone(),
        activation_key.clone(),
    ).await?;

    // Send activation email (async, non-blocking like Spring Boot @Async)
    if let Some(ref email_service) = state.email_service {
        let user_name = user.first_name.as_deref().unwrap_or(&user.login);
        // Fire and forget - don't block registration on email sending
        let _ = email_service.send_activation_email(&user.email, user_name, &activation_key).await;
    }
<%_ } else { _%>
    // Check login - error if already exists
    if let Ok(Some(_)) = UserService::find_by_login(&state.db, &request.login.to_lowercase()).await {
        return Err(AppError::BadRequest("Login already in use".to_string()));
    }

    // Check email - error if already exists
    if let Ok(Some(_)) = UserService::find_by_email(&state.db, &request.email.to_lowercase()).await {
        return Err(AppError::BadRequest("Email already in use".to_string()));
    }

    // Create user (already activated since email is disabled)
    let _user = UserService::create_registered_user(
        &state.db,
        request.login.to_lowercase(),
        request.email.to_lowercase(),
        &request.password,
        request.lang_key.clone(),
    ).await?;
<%_ } _%>
<%_ } else { _%>
    let mut conn = state.pool.get().map_err(|e| AppError::Internal(e.to_string()))?;

<%_ if (enableEmail) { _%>
    // Check login - remove non-activated duplicate, error if activated exists
    if let Ok(existing) = UserService::find_by_login(&mut conn, &request.login.to_lowercase()) {
        if existing.activated {
            return Err(AppError::BadRequest("Login already in use".to_string()));
        }
        // Remove non-activated user (like Spring Boot)
        let _ = UserService::delete(&mut conn, existing.id);
    }

    // Check email - remove non-activated duplicate, error if activated exists
    if let Ok(Some(existing)) = UserService::find_by_email_ignore_case(&mut conn, &request.email) {
        if existing.activated {
            return Err(AppError::BadRequest("Email already in use".to_string()));
        }
        // Remove non-activated user (like Spring Boot)
        let _ = UserService::delete(&mut conn, existing.id);
    }

    // Generate activation key
    let activation_key = generate_random_key();

    // Create user (not activated)
    let user = UserService::create_with_activation(
        &mut conn,
        request.login.to_lowercase(),
        request.email.to_lowercase(),
        &request.password,
        request.lang_key.clone(),
        activation_key.clone(),
    )?;

    // Send activation email (async, non-blocking like Spring Boot @Async)
    if let Some(ref email_service) = state.email_service {
        let user_name = user.first_name.as_deref().unwrap_or(&user.login);
        // Fire and forget - don't block registration on email sending
        let _ = email_service.send_activation_email(&user.email, user_name, &activation_key).await;
    }
<%_ } else { _%>
    // Check login - error if already exists
    if UserService::find_by_login(&mut conn, &request.login.to_lowercase()).is_ok() {
        return Err(AppError::BadRequest("Login already in use".to_string()));
    }

    // Check email - error if already exists
    if UserService::find_by_email(&mut conn, &request.email.to_lowercase()).is_ok() {
        return Err(AppError::BadRequest("Email already in use".to_string()));
    }

    // Create user (already activated since email is disabled)
    let _user = UserService::create_registered_user(
        &mut conn,
        request.login.to_lowercase(),
        request.email.to_lowercase(),
        &request.password,
        request.lang_key.clone(),
    )?;
<%_ } _%>
<%_ } _%>

    Ok(StatusCode::CREATED)
}
<%_ } _%>

<%_ if (enableEmail) { _%>
/// Generate a random key for activation/reset (20 characters)
/// Matches Spring Boot RandomUtil.generateActivationKey() / generateResetKey()
fn generate_random_key() -> String {
    use rand::Rng;
    let mut rng = rand::thread_rng();
    (0..20)
        .map(|_| rng.sample(rand::distributions::Alphanumeric) as char)
        .collect()
}

/// Activation query parameters
#[derive(Debug, Deserialize)]
pub struct ActivateParams {
    /// Activation key from email
    pub key: String,
}

/// Password reset finish request (matches Spring Boot KeyAndPasswordVM)
#[derive(Debug, Deserialize<%_ if (enableSwaggerCodegen) { _%>, ToSchema<%_ } _%>)]
#[serde(rename_all = "camelCase")]
pub struct KeyAndPasswordVM {
    /// Reset key from email
    pub key: String,
    /// New password (4-100 characters)
    pub new_password: String,
}

/// GET /api/activate - Activate user account
///
/// Matches Spring Boot JHipster AccountResource.activateAccount():
/// - Returns 200 OK on success
/// - Returns 500 Internal Server Error if no user found for activation key
<%_ if (enableSwaggerCodegen) { _%>
#[utoipa::path(
    get,
    path = "/api/activate",
    tag = "account",
    params(
        ("key" = String, Query, description = "Activation key from email")
    ),
    responses(
        (status = 200, description = "Account activated successfully"),
        (status = 500, description = "No user was found for this activation key")
    )
)]
<%_ } _%>
pub async fn activate(
    State(state): State<AppState>,
    Query(params): Query<ActivateParams>,
) -> Result<StatusCode, AppError> {
<%_ if (devDatabaseTypeMongodb) { _%>
    // Find user by activation key, set activated=true, clear activationKey
    let user = UserService::activate_by_key(&state.db, &params.key).await?;

    match user {
        Some(_) => Ok(StatusCode::OK),
        // Spring Boot throws RuntimeException (500) for invalid key
        None => Err(AppError::Internal("No user was found for this activation key".to_string())),
    }
<%_ } else { _%>
    let mut conn = state.pool.get().map_err(|e| AppError::Internal(e.to_string()))?;

    // Find user by activation key, set activated=true, clear activationKey
    let user = UserService::activate_by_key(&mut conn, &params.key)?;

    match user {
        Some(_) => Ok(StatusCode::OK),
        // Spring Boot throws RuntimeException (500) for invalid key
        None => Err(AppError::Internal("No user was found for this activation key".to_string())),
    }
<%_ } _%>
}

/// POST /api/account/reset-password/init - Request password reset
///
/// Matches Spring Boot JHipster AccountResource.requestPasswordReset():
/// - Accepts raw email string as request body (not JSON)
/// - Only allows reset for activated users
/// - Always returns 200 OK (prevents email enumeration)
/// - Logs warning for non-existing email
<%_ if (enableSwaggerCodegen) { _%>
#[utoipa::path(
    post,
    path = "/api/account/reset-password/init",
    tag = "account",
    request_body = String,
    responses(
        (status = 200, description = "Password reset email sent if account exists")
    )
)]
<%_ } _%>
pub async fn reset_password_init(
    State(state): State<AppState>,
    body: String,
) -> Result<StatusCode, AppError> {
    let email = body.trim();

<%_ if (devDatabaseTypeMongodb) { _%>
    // Find user by email (case-insensitive)
    if let Ok(Some(user)) = UserService::find_by_email_ignore_case(&state.db, email).await {
        // Only allow reset for activated users (like Spring Boot)
        if user.activated {
            // Generate reset key
            let reset_key = generate_random_key();

            // Update user with reset key and reset date
            if let Some(id) = user.id {
                let _ = UserService::set_reset_key(&state.db, id, reset_key.clone()).await;

                // Send reset email (async, non-blocking)
                if let Some(ref email_service) = state.email_service {
                    let user_name = user.first_name.as_deref().unwrap_or(&user.login);
                    let _ = email_service.send_password_reset_email(&user.email, user_name, &reset_key).await;
                }
            }
        }
    } else {
        // Log warning for non-existing email (like Spring Boot)
        // "Pretend the request has been successful to prevent checking which emails really exist"
        tracing::warn!("Password reset requested for non existing mail: {}", email);
    }
<%_ } else { _%>
    let mut conn = state.pool.get().map_err(|e| AppError::Internal(e.to_string()))?;

    // Find user by email (case-insensitive)
    if let Ok(Some(user)) = UserService::find_by_email_ignore_case(&mut conn, email) {
        // Only allow reset for activated users (like Spring Boot)
        if user.activated {
            // Generate reset key
            let reset_key = generate_random_key();

            // Update user with reset key and reset date
            let _ = UserService::set_reset_key(&mut conn, user.id, reset_key.clone());

            // Send reset email (async, non-blocking)
            if let Some(ref email_service) = state.email_service {
                let user_name = user.first_name.as_deref().unwrap_or(&user.login);
                let _ = email_service.send_password_reset_email(&user.email, user_name, &reset_key).await;
            }
        }
    } else {
        // Log warning for non-existing email (like Spring Boot)
        // "Pretend the request has been successful to prevent checking which emails really exist"
        tracing::warn!("Password reset requested for non existing mail: {}", email);
    }
<%_ } _%>

    // Always return OK to prevent email enumeration (like Spring Boot)
    Ok(StatusCode::OK)
}

/// POST /api/account/reset-password/finish - Complete password reset
///
/// Matches Spring Boot JHipster AccountResource.finishPasswordReset():
/// - Validates password length (4-100 characters)
/// - Validates reset key exists and is within 24-hour window
/// - Returns 400 for invalid password
/// - Returns 500 for invalid/expired reset key
<%_ if (enableSwaggerCodegen) { _%>
#[utoipa::path(
    post,
    path = "/api/account/reset-password/finish",
    tag = "account",
    request_body = KeyAndPasswordVM,
    responses(
        (status = 200, description = "Password reset successfully"),
        (status = 400, description = "Invalid password (must be 4-100 characters)"),
        (status = 500, description = "No user was found for this reset key")
    )
)]
<%_ } _%>
pub async fn reset_password_finish(
    State(state): State<AppState>,
    Json(request): Json<KeyAndPasswordVM>,
) -> Result<StatusCode, AppError> {
    // Validate password length (matching Spring Boot)
    if is_password_length_invalid(&request.new_password) {
        return Err(AppError::BadRequest("Password must be between 4 and 100 characters".to_string()));
    }

<%_ if (devDatabaseTypeMongodb) { _%>
    // Complete password reset with 24-hour validation
    let user = UserService::complete_password_reset(&state.db, &request.new_password, &request.key).await?;

    match user {
        Some(_) => Ok(StatusCode::OK),
        // Spring Boot throws RuntimeException (500) for invalid/expired key
        None => Err(AppError::Internal("No user was found for this reset key".to_string())),
    }
<%_ } else { _%>
    let mut conn = state.pool.get().map_err(|e| AppError::Internal(e.to_string()))?;

    // Complete password reset with 24-hour validation
    let user = UserService::complete_password_reset(&mut conn, &request.new_password, &request.key)?;

    match user {
        Some(_) => Ok(StatusCode::OK),
        // Spring Boot throws RuntimeException (500) for invalid/expired key
        None => Err(AppError::Internal("No user was found for this reset key".to_string())),
    }
<%_ } _%>
}
<%_ } _%>

#[cfg(test)]
mod tests {
<%_ if (authenticationTypeJwt) { _%>
    use super::*;
<%_ } _%>

<%_ if (authenticationTypeJwt) { _%>
    #[test]
    fn test_login_request_deserialization() {
        let json = r#"{"username":"testuser","password":"password123","remember_me":true}"#;
        let request: LoginRequest = serde_json::from_str(json).unwrap();
        assert_eq!(request.username, "testuser");
        assert_eq!(request.password, "password123");
        assert!(request.remember_me);
    }

    #[test]
    fn test_login_request_default_remember_me() {
        let json = r#"{"username":"testuser","password":"password123"}"#;
        let request: LoginRequest = serde_json::from_str(json).unwrap();
        assert_eq!(request.username, "testuser");
        assert!(!request.remember_me);
    }

    #[test]
    fn test_login_response_serialization() {
        let response = LoginResponse {
            id_token: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.test.signature".to_string(),
        };
        let json = serde_json::to_string(&response).unwrap();
        assert!(json.contains("id_token"));
        assert!(json.contains("eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9"));
    }

    #[test]
    fn test_change_password_request_deserialization() {
        // Uses camelCase to match Angular client format
        let json = r#"{"currentPassword":"oldpass","newPassword":"newpass123"}"#;
        let request: ChangePasswordRequest = serde_json::from_str(json).unwrap();
        assert_eq!(request.current_password, "oldpass");
        assert_eq!(request.new_password, "newpass123");
    }

    #[test]
    fn test_login_request_debug() {
        let request = LoginRequest {
            username: "testuser".to_string(),
            password: "password123".to_string(),
            remember_me: false,
        };
        let debug_str = format!("{:?}", request);
        assert!(debug_str.contains("testuser"));
    }

    #[test]
    fn test_login_response_debug() {
        let response = LoginResponse {
            id_token: "test_token".to_string(),
        };
        let debug_str = format!("{:?}", response);
        assert!(debug_str.contains("test_token"));
    }

    #[test]
    fn test_change_password_request_debug() {
        let request = ChangePasswordRequest {
            current_password: "oldpass".to_string(),
            new_password: "newpass".to_string(),
        };
        let debug_str = format!("{:?}", request);
        assert!(debug_str.contains("oldpass"));
    }
<%_ } else { _%>
    #[test]
    fn test_oauth2_account_endpoint() {
        // For OAuth2, the account endpoint returns user info from the token
        // No local authentication is performed
        assert!(true);
    }
<%_ } _%>
}

<%_ if (authenticationTypeJwt && !devDatabaseTypeMongodb) { _%>
#[cfg(test)]
mod integration_tests {
    use super::*;
    use axum::{middleware, Router};
    use axum_test::TestServer;
    use crate::test_utils::{create_test_pool, create_test_config, create_test_admin, create_test_user, generate_test_token};
    use crate::middleware::auth::auth_middleware;

    fn create_test_app() -> (TestServer, crate::AppState) {
        let pool = create_test_pool();
        let config = create_test_config();
        let state = crate::AppState {
            pool,
            config,
<%_ if (enableEmail) { _%>
            email_service: None,
<%_ } _%>
<%_ if (serviceDiscoveryConsul) { _%>
            consul_service: None,
<%_ } _%>
        };

        let app = Router::new()
            .nest("/api/authenticate", auth_routes())
            .nest(
                "/api/account",
                routes().layer(middleware::from_fn_with_state(state.clone(), auth_middleware)),
            )
            .with_state(state.clone());

        let server = TestServer::new(app).unwrap();
        (server, state)
    }

    #[tokio::test]
    async fn test_authenticate_success() {
        let (server, state) = create_test_app();
        create_test_admin(&state.pool);

        let login_request = serde_json::json!({
            "username": "admin",
            "password": "admin123",
            "remember_me": false
        });

        let response = server
            .post("/api/authenticate")
            .json(&login_request)
            .await;

        assert_eq!(response.status_code(), StatusCode::OK);
        let text = response.text();
        assert!(text.contains("id_token"));
    }

    #[tokio::test]
    async fn test_authenticate_with_remember_me() {
        let (server, state) = create_test_app();
        create_test_admin(&state.pool);

        let login_request = serde_json::json!({
            "username": "admin",
            "password": "admin123",
            "remember_me": true
        });

        let response = server
            .post("/api/authenticate")
            .json(&login_request)
            .await;

        assert_eq!(response.status_code(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_authenticate_wrong_password() {
        let (server, state) = create_test_app();
        create_test_admin(&state.pool);

        let login_request = serde_json::json!({
            "username": "admin",
            "password": "wrongpassword"
        });

        let response = server
            .post("/api/authenticate")
            .json(&login_request)
            .await;

        assert_eq!(response.status_code(), StatusCode::UNAUTHORIZED);
    }

    #[tokio::test]
    async fn test_authenticate_user_not_found() {
        let (server, _state) = create_test_app();

        let login_request = serde_json::json!({
            "username": "nonexistent",
            "password": "password123"
        });

        let response = server
            .post("/api/authenticate")
            .json(&login_request)
            .await;

        assert_eq!(response.status_code(), StatusCode::UNAUTHORIZED);
    }

    #[tokio::test]
    async fn test_authenticate_returns_authorization_header() {
        let (server, state) = create_test_app();
        create_test_admin(&state.pool);

        let login_request = serde_json::json!({
            "username": "admin",
            "password": "admin123"
        });

        let response = server
            .post("/api/authenticate")
            .json(&login_request)
            .await;

        assert_eq!(response.status_code(), StatusCode::OK);
        let headers = response.headers();
        assert!(headers.contains_key("authorization"));
        let auth_header = headers.get("authorization").unwrap().to_str().unwrap();
        assert!(auth_header.starts_with("Bearer "));
    }

    #[tokio::test]
    async fn test_get_account() {
        let (server, state) = create_test_app();
        create_test_admin(&state.pool);

        let token = generate_test_token(
            &state.config,
            "admin",
            &["ROLE_ADMIN".to_string(), "ROLE_USER".to_string()],
        );

        let response = server
            .get("/api/account")
            .add_header("Authorization".parse().unwrap(), format!("Bearer {}", token).parse().unwrap())
            .await;

        assert_eq!(response.status_code(), StatusCode::OK);
        let text = response.text();
        assert!(text.contains("admin"));
        assert!(text.contains("admin@localhost"));
        assert!(text.contains("ROLE_ADMIN"));
    }

    #[tokio::test]
    async fn test_get_account_unauthorized() {
        let (server, _state) = create_test_app();

        let response = server
            .get("/api/account")
            .await;

        // Without token, the auth middleware should reject with unauthorized
        assert_eq!(response.status_code(), StatusCode::UNAUTHORIZED);
    }

    #[tokio::test]
    async fn test_change_password_success() {
        let (server, state) = create_test_app();
        create_test_admin(&state.pool);

        let token = generate_test_token(
            &state.config,
            "admin",
            &["ROLE_ADMIN".to_string(), "ROLE_USER".to_string()],
        );

        // Uses camelCase to match Angular client format
        let change_request = serde_json::json!({
            "currentPassword": "admin123",
            "newPassword": "newpassword456"
        });

        let response = server
            .post("/api/account/change-password")
            .add_header("Authorization".parse().unwrap(), format!("Bearer {}", token).parse().unwrap())
            .json(&change_request)
            .await;

        assert_eq!(response.status_code(), StatusCode::OK);

        // Verify new password works
        let login_request = serde_json::json!({
            "username": "admin",
            "password": "newpassword456"
        });

        let auth_response = server
            .post("/api/authenticate")
            .json(&login_request)
            .await;

        assert_eq!(auth_response.status_code(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_change_password_wrong_current() {
        let (server, state) = create_test_app();
        create_test_admin(&state.pool);

        let token = generate_test_token(
            &state.config,
            "admin",
            &["ROLE_ADMIN".to_string(), "ROLE_USER".to_string()],
        );

        // Uses camelCase to match Angular client format
        let change_request = serde_json::json!({
            "currentPassword": "wrongpassword",
            "newPassword": "newpassword456"
        });

        let response = server
            .post("/api/account/change-password")
            .add_header("Authorization".parse().unwrap(), format!("Bearer {}", token).parse().unwrap())
            .json(&change_request)
            .await;

        assert_eq!(response.status_code(), StatusCode::BAD_REQUEST);
    }

    #[tokio::test]
    async fn test_regular_user_get_account() {
        let (server, state) = create_test_app();
        create_test_user(&state.pool);

        let token = generate_test_token(
            &state.config,
            "user",
            &["ROLE_USER".to_string()],
        );

        let response = server
            .get("/api/account")
            .add_header("Authorization".parse().unwrap(), format!("Bearer {}", token).parse().unwrap())
            .await;

        assert_eq!(response.status_code(), StatusCode::OK);
        let text = response.text();
        assert!(text.contains("user"));
        assert!(text.contains("user@localhost"));
    }
}
<%_ } _%>
